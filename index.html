<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>英语提分系统</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root{
    --bg-gradient: radial-gradient(1200px at 10% 20%, rgba(124,77,255,.22), transparent 55%),
                   radial-gradient(900px at 90% 0%, rgba(0,200,245,.18), transparent 60%),
                   linear-gradient(180deg,#f3f4ff 0%,#f9fbff 60%,#fef8ff 100%);
    --surface: rgba(255,255,255,0.9);
    --surface-alt: rgba(255,255,255,0.75);
    --text:#1f2749;
    --text-strong:#131836;
    --muted:#6d7691;
    --border:rgba(172,185,255,.35);
    --primary:#6653ff;
    --primary-dark:#4837d6;
    --accent:#ff8f6b;
    --success:#2fb173;
    --danger:#f26c6c;
    --shadow:0 20px 40px rgba(86,101,255,.18);
  }
  *{box-sizing:border-box;}
  body{font-family:"Segoe UI",Arial,"Microsoft YaHei";margin:0;color:var(--text);line-height:1.6;-webkit-font-smoothing:antialiased;background:#f3f4ff;position:relative;min-height:100vh;}
  body::before{content:"";position:fixed;inset:0;background:var(--bg-gradient);z-index:-2;}
  body::after{content:"";position:fixed;inset:0;background:linear-gradient(135deg,rgba(255,255,255,.55),rgba(255,255,255,.35));backdrop-filter:blur(24px);z-index:-1;}
  header{padding:42px 0 36px;position:relative;}
  header::before{content:"";position:absolute;inset:0;background:linear-gradient(135deg,rgba(112,82,255,.9),rgba(86,206,255,.85));border-bottom-left-radius:28px;border-bottom-right-radius:28px;box-shadow:0 35px 70px rgba(86,101,255,.25);}
  header .header-top,header p{width:min(1160px,calc(100% - 48px));margin:0 auto;position:relative;z-index:1;color:#fff;}
  header .header-top{display:flex;align-items:center;justify-content:space-between;gap:18px;flex-wrap:wrap;}
  header h1{margin:0;font-size:32px;font-weight:700;letter-spacing:.6px;}
  header p{margin-top:14px;color:rgba(255,255,255,.86);font-size:15px;}
  header .header-link{color:#fff;text-decoration:none;background:rgba(255,255,255,0.22);padding:10px 22px;border-radius:999px;font-size:15px;font-weight:500;transition:all .25s ease;backdrop-filter:blur(8px);box-shadow:0 14px 28px rgba(15,23,42,.18);}
  header .header-link:hover{background:rgba(255,255,255,0.34);transform:translateY(-2px);}
  main{width:min(1160px,calc(100% - 48px));margin:38px auto 64px;display:grid;gap:32px;position:relative;z-index:1;}
  section{background:var(--surface);border-radius:24px;padding:32px 36px;border:1px solid rgba(255,255,255,.55);box-shadow:var(--shadow);display:flex;flex-direction:column;gap:26px;backdrop-filter:blur(18px);}
  h2{margin:0;font-size:24px;font-weight:700;color:var(--text-strong);display:flex;align-items:center;gap:10px;}
  h2::after{content:"";flex:1;height:2px;background:linear-gradient(90deg,rgba(102,83,255,.45),rgba(255,143,107,.28));border-radius:999px;}
  .input-row{display:flex;flex-wrap:wrap;gap:18px;align-items:center;}
  select,button{padding:11px 18px;border-radius:14px;font-size:15px;line-height:1.4;border:1px solid rgba(120,129,255,.35);background:var(--surface-alt);color:var(--text);transition:all .2s ease;min-width:168px;box-shadow:0 10px 24px rgba(102,83,255,.08);}
  select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 4px rgba(102,83,255,.22);}
  button{background:linear-gradient(135deg,var(--primary),#7a63ff);color:#fff;border-color:transparent;cursor:pointer;font-weight:600;letter-spacing:.3px;box-shadow:0 16px 28px rgba(102,83,255,.28);}
  button:hover{transform:translateY(-2px);box-shadow:0 22px 36px rgba(102,83,255,.32);}
  button:disabled{background:linear-gradient(135deg,#b8bff9,#c8cffc);color:#f5f7ff;cursor:not-allowed;box-shadow:none;transform:none;}
  .card{background:rgba(255,255,255,0.78);border-radius:20px;padding:26px 30px;border:1px solid rgba(120,129,255,.2);display:flex;flex-direction:column;gap:20px;min-height:170px;box-shadow:0 18px 34px rgba(31,39,73,.08);}
  .progress{font-size:14px;color:var(--muted);display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap;}
  .word{font-size:32px;font-weight:700;color:var(--text-strong);letter-spacing:.6px;}
  .meaning{font-size:18px;color:var(--muted);}
  .example{font-size:15px;color:#4b5875;background:rgba(102,83,255,.09);padding:12px 16px;border-radius:14px;}
  #wordOptionsContainer,#grammarOptionsContainer{display:flex;flex-direction:column;gap:14px;}
  .word-option,.grammar-option{background:rgba(255,255,255,0.85);border:1px solid rgba(146,154,255,.38);border-radius:16px;padding:15px 20px;cursor:pointer;transition:transform .18s ease,box-shadow .18s ease,border-color .18s ease,color .18s ease;display:flex;gap:12px;align-items:flex-start;box-shadow:0 14px 28px rgba(30,42,91,.06);}
  .word-option:hover,.grammar-option:hover{transform:translateY(-3px);box-shadow:0 22px 34px rgba(102,83,255,.18);border-color:rgba(102,83,255,.55);}
  .word-option.selected,.grammar-option.selected{border:2px solid var(--primary);box-shadow:0 18px 30px rgba(102,83,255,.28);}
  .word-option.correct,.grammar-option.correct{background:rgba(47,177,115,.12);border-color:rgba(47,177,115,.55);color:#1b6e45;}
  .word-option.wrong,.grammar-option.wrong{background:rgba(242,108,108,.12);border-color:rgba(242,108,108,.45);color:#8b2d2d;}
  .grammar-option-key{font-weight:700;min-width:26px;display:inline-block;color:var(--muted);}
  .grammar-question{font-size:21px;font-weight:600;color:var(--text-strong);min-height:54px;}
  .result-panel{margin-top:4px;padding:18px 20px;border-radius:16px;background:rgba(255,255,255,0.72);min-height:56px;border:1px dashed rgba(146,154,255,.4);display:flex;align-items:center;color:var(--muted);box-shadow:0 12px 24px rgba(31,39,73,.04);}

  .timer-bar{position:relative;height:6px;border-radius:999px;background:rgba(102,83,255,.12);overflow:hidden;margin-top:6px;}
  .timer-bar span{position:absolute;inset:0;background:linear-gradient(90deg,#6b4bff,#ff8f6b);transform-origin:left center;transform:scaleX(1);transition:transform linear;}
  .timer-label{font-size:13px;color:var(--muted);letter-spacing:.2px;display:flex;align-items:center;gap:8px;}
  .stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:20px;margin-top:4px;}
  .stat{background:rgba(255,255,255,0.82);border-radius:18px;padding:24px;border:1px solid rgba(120,129,255,.25);display:flex;flex-direction:column;gap:8px;align-items:flex-start;box-shadow:0 18px 32px rgba(31,39,73,.08);}
  .stat div:first-child{font-size:32px;font-weight:700;color:var(--text-strong);}
  .stat div:nth-child(2){font-size:14px;color:var(--muted);letter-spacing:.2px;}
  .sentence-area{display:flex;flex-direction:column;gap:18px;}
  .sentence-bank,.sentence-answer{display:flex;flex-wrap:wrap;gap:14px;padding:18px;border-radius:16px;min-height:74px;background:rgba(255,255,255,0.82);border:1px dashed rgba(146,154,255,.38);box-shadow:0 12px 26px rgba(30,42,91,.05);}
  .sentence-answer{background:rgba(250,251,255,0.9);}
  .sentence-token{padding:10px 18px;border-radius:14px;background:rgba(255,255,255,0.85);border:1px solid rgba(146,154,255,.32);cursor:pointer;user-select:none;transition:transform .12s ease,box-shadow .12s ease,border-color .12s ease;}
  .sentence-token:hover{transform:translateY(-2px);box-shadow:0 16px 24px rgba(102,83,255,.12);border-color:rgba(102,83,255,.45);}
  .sentence-token.correct{background:rgba(47,177,115,.12);border-color:rgba(47,177,115,.55);color:#1b6e45;cursor:default;box-shadow:none;}
  .sentence-token.wrong{background:rgba(242,108,108,.12);border-color:rgba(242,108,108,.45);color:#8b2d2d;cursor:default;box-shadow:none;}
  .sentence-token.disabled{cursor:not-allowed;opacity:.65;box-shadow:none;}
  footer{padding:28px 18px 48px;text-align:center;color:rgba(109,118,145,.9);font-size:13px;}
  @media (max-width:720px){
    header{padding:32px 0 28px;}
    header .header-top,header p,main{width:calc(100% - 32px);}
    section{padding:26px 22px;}
    .word{font-size:28px;}
    select,button{min-width:0;flex:1 1 150px;}
  }
</style></style>
</head>
<body>
<header>
  <div class="header-top">
    <h1>英语提分系统</h1>
    <a class="header-link" href="dashboard.html" title="查看所有学生的练习与积分数据">全员概览</a>
  </div>
  <p>先选学生，再按需要选择词库、语法或句库（互斥练习）</p>
</header>
<main>
  <section>
    <h2>1. 选择学生</h2>
    <div class="input-row">
      <select id="studentSelect"></select>
      <select id="wordBankSelect"></select>
      <select id="wordLetterSelect" style="display:none;"></select>
      <select id="grammarSetSelect"></select>
      <select id="sentenceSetSelect"></select>
      <button id="resetProgress">清除当前学生进度</button>
    </div>
    <div class="stats-grid" id="overallStats"></div>
  </section>

  <section id="wordSection">
    <h2>2. 单词练习 / 测验</h2>
    <div class="input-row" id="wordSessionControls">
      <select id="wordSessionTypeSelect" title="选择积分模式">
        <option value="practice" selected>练习模式（不计积分）</option>
        <option value="exam">测验模式（计积分）</option>
      </select>
      <select id="wordModeSelect" title="选择抽题策略">
        <option value="normal">正常练习</option>
        <option value="review">错词强化</option>
      </select>
      <select id="wordBatchSelect" title="选择本次测验的题目数量">
        <option value="20" selected>一次 20 题</option>
        <option value="50">一次 50 题</option>
        <option value="100">一次 100 题</option>
      </select>
      <button id="refreshWordSession">开始练习</button>
    </div>
    <div class="card">
      <div class="progress" id="vocabProgress"></div>
      <div class="timer-label" id="wordTimerLabel" style="display:none;">剩余 <strong>10 秒</strong></div>
      <div class="timer-bar" id="wordTimerBar" style="display:none;"><span></span></div>
      <div class="word" id="wordDisplay">请先选择学生</div>
      <div class="meaning" id="wordPrompt"></div>
      <div id="wordOptionsContainer"></div>
      <div class="example" id="exampleDisplay"></div>
    </div>
    <div class="input-row" style="display:none;margin-top:16px;">
      <button id="submitWordAnswer">确认答案</button>
      <button id="nextWord">下一题</button>
    </div>
    <div class="result-panel" id="wordFeedback"></div>
  </section>

  <section id="grammarSection">
    <h2>3. 语法选择题</h2>
    <div class="input-row" id="grammarSessionControls">
      <select id="grammarBatchSelect" title="选择本次题量">
        <option value="10">一次 10 题</option>
        <option value="20" selected>一次 20 题</option>
        <option value="30">一次 30 题</option>
        <option value="all">整套全部</option>
      </select>
      <button id="startGrammarSession">开始练习</button>
    </div>
    <div class="card">
      <div class="progress" id="grammarProgress"></div>
      <div class="timer-label" id="grammarTimerLabel" style="display:none;">剩余 <strong>60 秒</strong></div>
      <div class="timer-bar" id="grammarTimerBar" style="display:none;"><span></span></div>
      <div class="grammar-question" id="grammarQuestion">请选择语法题库</div>
      <div id="grammarOptionsContainer"></div>
      <div class="example" id="grammarExplanation" style="display:none;"></div>
    </div>
    <div class="input-row" style="margin-top:16px;">
      <button id="submitGrammarAnswer">确认答案</button>
      <button id="nextGrammarQuestion">下一题</button>
    </div>
    <div class="result-panel" id="grammarFeedback"></div>
  </section>

  <section id="sentenceSection">
    <h2>4. 句子重组测验</h2>
    <div class="card">
      <div class="progress" id="sentenceProgress"></div>
      <div class="timer-label" id="sentenceTimerLabel" style="display:none;">剩余 <strong>60 秒</strong></div>
      <div class="timer-bar" id="sentenceTimerBar" style="display:none;"><span></span></div>
      <div class="meaning" id="sentenceInstruction">请先选择学生</div>
      <div class="example" id="sentenceHint"></div>
      <div class="sentence-area">
        <div class="sentence-bank" id="sentenceOptionsContainer"></div>
        <div class="sentence-answer" id="sentenceAnswerContainer"></div>
      </div>
    </div>
    <div class="input-row" style="margin-top:16px;">
      <button id="resetSentenceSelection">撤回重选</button>
      <button id="submitSentenceAnswer">确认顺序</button>
      <button id="nextSentence">下一句</button>
    </div>
    <div class="result-panel" id="sentenceFeedback"></div>
  </section>
</main>
<footer>离线版 · 数据本地保存 · 可自由扩展</footer>

<script src="word_bank/vocabulary688.js"></script>
<script src="sentence_bank/sentences_200.js"></script>
<script src="word_bank/3500/register.js"></script>
<script src="word_bank/3500/a-vocab.js"></script>
<script src="word_bank/3500/b-vocab-dictionary-b.js"></script>
<script src="word_bank/3500/c-vocab-dictionary-c.js"></script>
<script src="word_bank/3500/d-vocab-dictionary-d.js"></script>
<script src="word_bank/3500/e-vocab-dictionary-e.js"></script>
<script src="word_bank/3500/f-vocab-dictionary-f.js"></script>
<script src="word_bank/3500/g-vocab-dictionary-g.js"></script>
<script src="word_bank/3500/h-vocab-dictionary-h.js"></script>
<script src="word_bank/3500/i-vocab-dictionary-i.js"></script>
<script src="word_bank/3500/i-vocab-dictionary-l.js"></script>
<script src="word_bank/3500/j-vocab-dictionary-j.js"></script>
<script src="word_bank/3500/k-vocab-dictionary-k.js"></script>
<script src="word_bank/3500/m-vocab-dictionary-m.js"></script>
<script src="word_bank/3500/n-vocab-dictionary-n.js"></script>
<script src="word_bank/3500/p-vocab-dictionary-p.js"></script>
<script src="word_bank/3500/q-vocabulary-js.js"></script>
<script src="word_bank/3500/r-vocabulary-js.js"></script>
<script src="word_bank/3500/s-vocabulary1.js"></script>
<script src="word_bank/3500/s-vocabulary2.js"></script>
<script src="word_bank/3500/t-vocabulary-js.js"></script>
<script src="word_bank/3500/u-vocabulary-js.js"></script>
<script src="word_bank/3500/v-vocabulary-js.js"></script>
<script src="word_bank/3500/y-vocabulary-js.js"></script>
<script src="word_bank/3500/z-vocabulary-js.js"></script>
<script src="word_bank/gaokao_core_688/register.js"></script>
<script src="word_bank/gaokao_core_688/bixiu1.js"></script>
<script src="word_bank/gaokao_core_688/bixiu2.js"></script>
<script src="word_bank/gaokao_core_688/bixiu3.js"></script>
<script src="word_bank/gaokao_core_688/xuanxiu1.js"></script>
<script src="word_bank/gaokao_core_688/xuanxiu2.js"></script>
<script src="word_bank/gaokao_core_688/xuanxiu3.js"></script>
<script src="word_bank/gaokao_core_688/xuanxiu4.js"></script>
<script src="grammar/grammar_multiple_choice/register.js"></script>
<script src="grammar/grammar_multiple_choice/01_subject_verb_agreement.js"></script>
<script src="grammar/grammar_multiple_choice/02_articles_numbers.js"></script>
<script src="grammar/grammar_multiple_choice/03_pronouns_prepositions.js"></script>
<script src="grammar/grammar_multiple_choice/04_adjectives_adverbs.js"></script>
<script src="grammar/grammar_multiple_choice/05_verbs_phrasal_verbs.js"></script>
<script src="grammar/grammar_multiple_choice/06_verb_tense_voice.js"></script>
<script src="grammar/grammar_multiple_choice/07_nonfinite_verbs.js"></script>
<script src="grammar/grammar_multiple_choice/08_modals_subjunctive.js"></script>
<script src="grammar/grammar_multiple_choice/09_sentence_components_types.js"></script>
<script src="grammar/grammar_multiple_choice/10_noun_clauses.js"></script>
<script src="grammar/grammar_multiple_choice/11_adverbial_clauses.js"></script>
<script src="grammar/grammar_multiple_choice/12_relative_clauses.js"></script>
<script>
const students = [
  "焦良瑾","庄优岳","曾媛媛","陈伟聪","李煜文","吴沛宜","王泽霖","吴苑萍","陈佳琳","黄钰莹","刘文锋","杨淳好","刘欣","梁鸿浩","杨映春","甘紫渊","黄书慧","谭铠淇","叶蕙仪","王诗涵","谢家锐","张育东","余乐欢","余欣莹","何厚玮","李襄","曹淑怡","王馨怡","叶思翰"
];

const rawCoreVocabulary = Array.isArray(window.vocabulary688) ? window.vocabulary688 : [];
const core688Items = rawCoreVocabulary.filter(entry => entry && entry.word).map(entry => ({
  word: entry.word,
  meaning: formatMeaning(entry),
  example: entry.example || "",
  posTags: normalizePosTokens(entry.pos)
}));

const meaningLookup = new Map();

function addMeaningToLookup(word, meaning){
  const key = typeof word === "string" ? word.trim().toLowerCase() : "";
  const value = typeof meaning === "string" ? meaning.trim() : "";
  if(!key || !value || value === "释义待补充" || value === "词组") return;
  if(!meaningLookup.has(key)) meaningLookup.set(key, value);
}

function registerMeaning(items){
  if(!Array.isArray(items)) return;
  items.forEach(item => {
    if(item && item.word && item.meaning){
      addMeaningToLookup(item.word, item.meaning);
    }
  });
}

function lookupMeaning(word){
  const key = typeof word === "string" ? word.trim().toLowerCase() : "";
  if(!key) return "";
  return meaningLookup.get(key) || "";
}

registerMeaning(core688Items);

const rawCet3500Map = window.vocab3500 && typeof window.vocab3500 === "object" ? window.vocab3500 : {};
const cet3500Letters = Object.keys(rawCet3500Map)
  .filter(letter => Array.isArray(rawCet3500Map[letter]) && rawCet3500Map[letter].length)
  .sort((a,b) => a.localeCompare(b, "zh-Hans-CN"));

const cet3500Banks = cet3500Letters.map(letter => {
  const normalized = normalize3500Entries(rawCet3500Map[letter]);
  return {
    id: `cet3500-${letter}`,
    name: `高中3500词库（${letter}）`,
    letter,
    parentId: "cet3500",
    items: normalized,
    count: normalized.length
  };
});

cet3500Banks.forEach(bank => registerMeaning(bank.items));

const rawTextbookMap = window.textbookVocab && typeof window.textbookVocab === "object" ? window.textbookVocab : {};
const textbookBanks = buildTextbookBanks(rawTextbookMap);

textbookBanks.forEach(bank => registerMeaning(bank.items));

const wordBanks = [
  {id:"core688",name:"高考核心688词库",items:core688Items},
  ...cet3500Banks,
  ...textbookBanks
];

const topLevelWordBanks = [
  {id:"core688",name:"高考核心688词库"},
  {id:"cet3500",name:"高中3500词库"},
  {id:"textbook",name:"高中教材词库"}
];

const subWordBankMap = {
  cet3500: cet3500Banks,
  textbook: textbookBanks
};

const rawSentenceData = Array.isArray(window.vocabularyData) ? window.vocabularyData : [];
const sentenceSetItems = rawSentenceData.filter(item => item && item.english);
const sentenceSets = [
  {id:"sentence200",name:"英语200句重组",items:sentenceSetItems}
];

const grammarBankOrder = Array.isArray(window.grammarQuestionOrder) ? window.grammarQuestionOrder : Object.keys(window.grammarQuestionBanks || {});
const rawGrammarBankMap = window.grammarQuestionBanks && typeof window.grammarQuestionBanks === "object" ? window.grammarQuestionBanks : {};
const grammarBanks = grammarBankOrder
  .map(id => {
    const bank = rawGrammarBankMap[id];
    if(!bank || typeof bank !== "object") return null;
    const questions = normalizeGrammarQuestions(bank.questions);
    return {
      id,
      name: bank.title || bank.name || id,
      questions
    };
  })
  .filter(Boolean);

const DEFAULT_WORD_BATCH = 20;

const WORD_TIME_LIMIT = 10;
const GRAMMAR_TIME_LIMIT = 60;
const SENTENCE_TIME_LIMIT = 60;
const WORD_TIMEOUT_PENALTY = -10;

let wordPracticeMode = "normal";
let wordSessionType = "practice";

const WORD_SCORE_RULES = {
  20: {fullBonus: 20, penaltyThreshold: 0.8, penalty: -10, quit: -10},
  50: {fullBonus: 80, penaltyThreshold: 0.7, penalty: -20, quit: -20},
  100: {fullBonus: 150, penaltyThreshold: 0.6, penalty: -30, quit: -30}
};

const WORD_SCORE_STORAGE_KEY = "wordPracticeScoreboard";

const SCORE_DEFAULTS = {
  total: 0,
  reward: 0,
  penalty: 0,
  redeemable: 0,
  history: []
};

let wordScoreboard = loadWordScoreboard();

let currentStudent = null;
let activeWordBank = null;
let activeVocabulary = [];
let currentVocabIndex = 0;
let currentWordOptions = [];
let selectedWordOptionIndex = null;
let wordHistory = [];
let wordSessionState = null;
let wordAutoAdvanceTimer = null;
let unfamiliarIndices = new Set();
let wordQuestionGraded = false;
let wordSessionNeedsStart = true;

let activeSentenceSet = null;
let currentSentenceIndex = 0;
let sentenceHistory = [];
let sentenceSessionState = null;
let sentenceAvailableTokens = [];
let sentenceSelectedTokens = [];
let sentenceOriginalTokens = [];
let sentenceLocked = false;

let activeGrammarSet = null;
let grammarSessionState = null;
let grammarHistory = [];
let grammarCurrentOptions = [];
let grammarSelectedOptionKey = null;
let grammarQuestionGraded = false;
let grammarAutoAdvanceTimer = null;
let grammarSessionNeedsStart = true;

let wordTimerInterval = null;
let wordTimerDeadline = 0;
let grammarTimerInterval = null;
let grammarTimerDeadline = 0;
let sentenceTimerInterval = null;
let sentenceTimerDeadline = 0;

const studentSelect = document.getElementById("studentSelect");
const wordBankSelect = document.getElementById("wordBankSelect");
const wordLetterSelect = document.getElementById("wordLetterSelect");
const grammarSetSelect = document.getElementById("grammarSetSelect");
const sentenceSetSelect = document.getElementById("sentenceSetSelect");
const resetBtn = document.getElementById("resetProgress");

const wordSection = document.getElementById("wordSection");
const grammarSection = document.getElementById("grammarSection");
const sentenceSection = document.getElementById("sentenceSection");

const wordSessionTypeSelect = document.getElementById("wordSessionTypeSelect");
const wordModeSelect = document.getElementById("wordModeSelect");
const wordBatchSelect = document.getElementById("wordBatchSelect");
const refreshWordSessionBtn = document.getElementById("refreshWordSession");

const vocabProgress = document.getElementById("vocabProgress");
const wordDisplay = document.getElementById("wordDisplay");
const wordPrompt = document.getElementById("wordPrompt");
const wordOptionsContainer = document.getElementById("wordOptionsContainer");
const submitWordBtn = document.getElementById("submitWordAnswer");
const nextWordBtn = document.getElementById("nextWord");
const wordFeedback = document.getElementById("wordFeedback");
const exampleDisplay = document.getElementById("exampleDisplay");
const wordTimerLabel = document.getElementById("wordTimerLabel");
const wordTimerBar = document.getElementById("wordTimerBar");

const grammarBatchSelect = document.getElementById("grammarBatchSelect");
const startGrammarSessionBtn = document.getElementById("startGrammarSession");
const grammarProgress = document.getElementById("grammarProgress");
const grammarQuestionDisplay = document.getElementById("grammarQuestion");
const grammarOptionsContainer = document.getElementById("grammarOptionsContainer");
const grammarExplanation = document.getElementById("grammarExplanation");
const grammarFeedback = document.getElementById("grammarFeedback");
const submitGrammarBtn = document.getElementById("submitGrammarAnswer");
const nextGrammarBtn = document.getElementById("nextGrammarQuestion");
const grammarTimerLabel = document.getElementById("grammarTimerLabel");
const grammarTimerBar = document.getElementById("grammarTimerBar");

const sentenceProgress = document.getElementById("sentenceProgress");
const sentenceInstruction = document.getElementById("sentenceInstruction");
const sentenceHint = document.getElementById("sentenceHint");
const sentenceOptionsContainer = document.getElementById("sentenceOptionsContainer");
const sentenceAnswerContainer = document.getElementById("sentenceAnswerContainer");
const resetSentenceBtn = document.getElementById("resetSentenceSelection");
const submitSentenceBtn = document.getElementById("submitSentenceAnswer");
const nextSentenceBtn = document.getElementById("nextSentence");
const sentenceFeedback = document.getElementById("sentenceFeedback");
const sentenceTimerLabel = document.getElementById("sentenceTimerLabel");
const sentenceTimerBar = document.getElementById("sentenceTimerBar");

const overallStats = document.getElementById("overallStats");

if(wordSessionTypeSelect){
  wordSessionType = wordSessionTypeSelect.value === "exam" ? "exam" : "practice";
}

if(wordModeSelect){
  wordPracticeMode = wordModeSelect.value === "review" ? "review" : "normal";
}

students.forEach(name => {
  const option = document.createElement("option");
  option.value = name;
  option.textContent = name;
  studentSelect.appendChild(option);
});
studentSelect.insertAdjacentHTML("afterbegin","<option value='' disabled selected>选择学生姓名</option>");

topLevelWordBanks.forEach(bank => {
  const option = document.createElement("option");
  option.value = bank.id;
  option.textContent = bank.name;
  wordBankSelect.appendChild(option);
});
wordBankSelect.insertAdjacentHTML("afterbegin","<option value='' selected>选择词库（单词测验）</option>");
wordBankSelect.value = "";

if(wordLetterSelect){
  populateSubBankSelect();
  wordLetterSelect.value = "";
  wordLetterSelect.style.display = "none";
  wordLetterSelect.disabled = true;
}

sentenceSets.forEach(set => {
  const option = document.createElement("option");
  option.value = set.id;
  option.textContent = set.name;
  sentenceSetSelect.appendChild(option);
});
sentenceSetSelect.insertAdjacentHTML("afterbegin","<option value='' selected>选择句库（句子重组）</option>");
sentenceSetSelect.value = "";

if(grammarSetSelect){
  grammarBanks.forEach(bank => {
    const option = document.createElement("option");
    option.value = bank.id;
    const countLabel = bank.questions.length ? `（${bank.questions.length} 题）` : "";
    option.textContent = `${bank.name || bank.id}${countLabel}`;
    grammarSetSelect.appendChild(option);
  });
  grammarSetSelect.insertAdjacentHTML("afterbegin","<option value='' selected>选择语法题库</option>");
  grammarSetSelect.value = "";
}

function populateSubBankSelect(parentId){
  if(!wordLetterSelect) return;
  wordLetterSelect.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "选择子词库";
  placeholder.disabled = true;
  placeholder.selected = true;
  wordLetterSelect.appendChild(placeholder);
  const banks = parentId && subWordBankMap[parentId] ? subWordBankMap[parentId] : [];
  banks.forEach(bank => {
    const option = document.createElement("option");
    option.value = bank.id;
    const countLabel = bank.count ? `（${bank.count} 词）` : "";
    option.textContent = `${bank.name || bank.id}${countLabel}`;
    wordLetterSelect.appendChild(option);
  });
  const hasBanks = banks.length > 0;
  wordLetterSelect.style.display = hasBanks ? "" : "none";
  wordLetterSelect.disabled = !hasBanks;
  if(!hasBanks){
    wordLetterSelect.value = "";
  }
}

function loadUnfamiliarSet(){
  unfamiliarIndices = new Set();
  const key = storageKey("unfamiliar");
  if(!key) return;
  const raw = safeParse(localStorage.getItem(key), []);
  if(!Array.isArray(raw)) return;
  raw.forEach(idx => {
    if(Number.isInteger(idx)) unfamiliarIndices.add(idx);
  });
}

function saveUnfamiliarSet(){
  const key = storageKey("unfamiliar");
  if(!key) return;
  if(!unfamiliarIndices || unfamiliarIndices.size === 0){
    localStorage.removeItem(key);
    return;
  }
  localStorage.setItem(key, JSON.stringify(Array.from(unfamiliarIndices)));
}

function storageKey(type){
  if(!currentStudent || !activeWordBank) return null;
  return `${currentStudent}-${activeWordBank.id}-${type}`;
}

function sentenceStorageKey(type){
  if(!currentStudent || !activeSentenceSet) return null;
  return `${currentStudent}-sentence-${activeSentenceSet.id}-${type}`;
}

function grammarStorageKey(type){
  if(!currentStudent || !activeGrammarSet) return null;
  return `${currentStudent}-grammar-${activeGrammarSet.id}-${type}`;
}

function safeParse(raw,fallback){
  if(!raw) return fallback;
  try{return JSON.parse(raw);}catch(e){return fallback;}
}

function getWordSessionTypeLabel(type){
  return type === "exam" ? "测验模式" : "练习模式";
}

function currentWordSessionType(){
  if(wordSessionState && wordSessionState.sessionType){
    return wordSessionState.sessionType === "exam" ? "exam" : "practice";
  }
  return wordSessionType === "exam" ? "exam" : "practice";
}

function isExamWordSession(){
  return currentWordSessionType() === "exam";
}

function completePracticeSession(message){
  if(!wordSessionState) return;
  if(Array.isArray(wordSessionState.indices)){
    const size = wordSessionState.indices.length;
    if(Number.isInteger(wordSessionState.pointer)){
      wordSessionState.pointer = Math.max(wordSessionState.pointer, size);
    }else{
      wordSessionState.pointer = size;
    }
  }
  wordSessionState.scoreApplied = true;
  saveWordSessionState();
  if(message){
    broadcastWordScoreMessage(message);
  }
}

function buildPracticeTimeoutMessage(info){
  if(!info) info = {};
  const wordLabel = info.word ? info.word : "当前单词";
  const meaningLabel = info.meaning ? ` — ${info.meaning}` : "";
  return `练习模式倒计时结束，不计积分。错词：${wordLabel}${meaningLabel}`;
}

function summarizeWordSessionAnswers(){
  if(!wordSessionState || !Array.isArray(wordSessionState.answers)){
    return {answeredCount: 0, correctCount: 0};
  }
  const map = new Map();
  wordSessionState.answers.forEach(entry => {
    if(!entry || typeof entry !== "object") return;
    const idx = Number(entry.index);
    if(!Number.isInteger(idx)) return;
    map.set(idx, Boolean(entry.correct));
  });
  let correctCount = 0;
  map.forEach(value => {
    if(value) correctCount++;
  });
  return {answeredCount: map.size, correctCount};
}

function failExamSessionOnTimeout(info){
  if(!currentStudent || !wordSessionState) return;
  const totalCount = Array.isArray(wordSessionState.indices) ? wordSessionState.indices.length : 0;
  const {answeredCount, correctCount} = summarizeWordSessionAnswers();
  const accuracy = answeredCount > 0 ? correctCount / answeredCount : 0;
  const detail = {
    outcome: "timeout",
    reason: "timeout",
    batchSize: wordSessionState.batchSize || 0,
    correctCount,
    totalCount,
    answeredCount,
    accuracy,
    mode: wordSessionState.mode === "review" ? "review" : "normal"
  };
  if(Array.isArray(wordSessionState.indices)){
    const size = wordSessionState.indices.length;
    if(Number.isInteger(wordSessionState.pointer)){
      wordSessionState.pointer = Math.max(wordSessionState.pointer, size);
    }else{
      wordSessionState.pointer = size;
    }
  }
  wordSessionState.scoreApplied = true;
  saveWordSessionState();
  const applied = applyWordScoreChange(currentStudent, WORD_TIMEOUT_PENALTY, detail);
  const baseFeedback = wordFeedback.textContent || "";
  const wordLabel = info && info.word ? info.word : "当前单词";
  const meaningLabel = info && info.meaning ? ` — ${info.meaning}` : "";
  const failureText = `测验倒计时结束，本轮失败，扣除 ${Math.abs(WORD_TIMEOUT_PENALTY)} 分。错词：${wordLabel}${meaningLabel}`;
  let combined = baseFeedback ? `${baseFeedback} ｜ ${failureText}` : failureText;
  if(applied && applied.record){
    const scoreMessage = buildWordScoreFeedbackMessage(applied.record, Number(applied.total) || 0, Number(applied.redeemable));
    if(scoreMessage){
      combined = `${combined} ｜ ${scoreMessage}`;
    }
  }
  wordFeedback.textContent = combined;
  renderOverallStats();
}

function endWordSessionOnTimeout(info){
  if(!wordSessionState) return;
  const previousFeedback = wordFeedback.textContent;
  if(isExamWordSession()){
    failExamSessionOnTimeout(info);
  }else{
    const practiceMessage = buildPracticeTimeoutMessage(info || {});
    completePracticeSession(practiceMessage);
    renderOverallStats();
  }
  const finalFeedback = wordFeedback.textContent || previousFeedback;
  renderWordQuestion();
  if(finalFeedback){
    wordFeedback.textContent = finalFeedback;
  }
}

function loadWordProgress(){
  currentVocabIndex = 0;
  wordHistory = [];
  wordSessionState = null;
  wordSessionNeedsStart = true;

  if(!currentStudent || !activeWordBank){
    unfamiliarIndices = new Set();
    if(wordBatchSelect) wordBatchSelect.value = String(DEFAULT_WORD_BATCH);
    return;
  }

  const historyKey = storageKey("wordHistory");
  if(historyKey){
    const raw = localStorage.getItem(historyKey);
    const parsed = safeParse(raw, []);
    wordHistory = Array.isArray(parsed)
      ? parsed.filter(entry => entry && Number.isInteger(entry.index) && typeof entry.correct === "boolean")
          .filter(entry => entry.index >= 0 && entry.index < activeVocabulary.length)
      : [];
  }

  loadUnfamiliarSet();
  unfamiliarIndices = new Set(Array.from(unfamiliarIndices).filter(idx => Number.isInteger(idx) && idx >= 0 && idx < activeVocabulary.length));

  loadWordSessionState();
  const hasActiveSession = Boolean(
    wordSessionState &&
    Array.isArray(wordSessionState.indices) &&
    wordSessionState.indices.length
  );
  if(hasActiveSession) evaluateWordSessionCompletion();
}

function loadWordSessionState(){
  const batchValue = wordBatchSelect ? Number(wordBatchSelect.value) : DEFAULT_WORD_BATCH;
  let desiredBatch = Number.isFinite(batchValue) && batchValue > 0 ? batchValue : DEFAULT_WORD_BATCH;

  const sessionKey = storageKey("wordSession");
  if(sessionKey){
    const raw = safeParse(localStorage.getItem(sessionKey), null);
    if(raw && Array.isArray(raw.indices)){
      const cleanedIndices = raw.indices
        .filter(idx => Number.isInteger(idx) && idx >= 0 && idx < activeVocabulary.length);
      if(cleanedIndices.length){
        const pointer = Number.isInteger(raw.pointer) ? Math.min(Math.max(raw.pointer, 0), cleanedIndices.length) : 0;
        const batchSize = Number.isFinite(raw.batchSize) && raw.batchSize > 0 ? raw.batchSize : DEFAULT_WORD_BATCH;
        const mode = raw.mode === "review" ? "review" : "normal";
        const sessionType = raw.sessionType === "practice" ? "practice" : "exam";
        const allowedIndices = new Set(cleanedIndices);
        const answers = Array.isArray(raw.answers)
          ? raw.answers
              .map(answer => ({
                index: Number.isInteger(answer.index) ? answer.index : null,
                correct: typeof answer.correct === "boolean" ? answer.correct : null
              }))
              .filter(entry => entry.index !== null && entry.correct !== null && allowedIndices.has(entry.index))
          : [];
        const scoreApplied = raw.scoreApplied === true;
        wordSessionState = {
          batchSize,
          indices: cleanedIndices,
          pointer,
          mode,
          sessionType,
          answers,
          scoreApplied
        };
        wordPracticeMode = mode;
        if(wordModeSelect) wordModeSelect.value = mode;
        wordSessionType = sessionType;
        if(wordSessionTypeSelect) wordSessionTypeSelect.value = sessionType;
        desiredBatch = wordSessionState.batchSize;
      }
    }
  }

  if(wordBatchSelect) wordBatchSelect.value = String(desiredBatch);

  if(!wordSessionState || !Array.isArray(wordSessionState.indices) || !wordSessionState.indices.length){
    wordSessionNeedsStart = true;
  }
}

function loadSentenceProgress(){
  currentSentenceIndex = 0;
  sentenceHistory = [];
  sentenceSessionState = null;

  if(!currentStudent || !activeSentenceSet) return;

  const legacyIndexKey = sentenceStorageKey("sentenceIndex");
  if(legacyIndexKey) localStorage.removeItem(legacyIndexKey);

  const historyKey = sentenceStorageKey("sentenceHistory");
  if(historyKey){
    const raw = localStorage.getItem(historyKey);
    const parsed = safeParse(raw, []);
    sentenceHistory = Array.isArray(parsed)
      ? parsed.filter(entry => entry && Number.isInteger(entry.index) && typeof entry.correct === "boolean")
          .filter(entry => entry.index >= 0 && entry.index < activeSentenceSet.items.length)
      : [];
  }

  loadSentenceSessionState();
}

function loadSentenceSessionState(){
  const totalSentences = activeSentenceSet ? activeSentenceSet.items.length : 0;
  const sessionKey = sentenceStorageKey("sentenceSession");
  if(sessionKey){
    const raw = safeParse(localStorage.getItem(sessionKey), null);
    if(raw && Array.isArray(raw.indices)){
      const cleaned = raw.indices.filter(idx => Number.isInteger(idx) && idx >= 0 && idx < totalSentences);
      if(cleaned.length){
        const pointer = Number.isInteger(raw.pointer) ? Math.min(Math.max(raw.pointer, 0), cleaned.length) : 0;
        sentenceSessionState = {indices: cleaned, pointer};
      }
    }
  }
  if(!sentenceSessionState){
    startNewSentenceSession();
  }else if(!sentenceSessionState.indices.length){
    startNewSentenceSession();
  }else{
    sentenceSessionState.pointer = Math.min(Math.max(sentenceSessionState.pointer, 0), sentenceSessionState.indices.length);
  }
}

function startNewSentenceSession(){
  stopSentenceTimer();
  const totalSentences = activeSentenceSet ? activeSentenceSet.items.length : 0;
  const indices = totalSentences ? shuffleArray(Array.from({length: totalSentences}, (_, idx) => idx)) : [];
  sentenceSessionState = {indices, pointer: 0};
  saveSentenceSessionState();
}

function saveSentenceSessionState(){
  const key = sentenceStorageKey("sentenceSession");
  if(!key) return;
  if(!sentenceSessionState || !sentenceSessionState.indices.length){
    localStorage.removeItem(key);
    return;
  }
  const payload = {
    indices: sentenceSessionState.indices,
    pointer: sentenceSessionState.pointer
  };
  localStorage.setItem(key, JSON.stringify(payload));
}

function loadGrammarHistory(){
  grammarHistory = [];
  if(!currentStudent || !activeGrammarSet) return;
  const key = grammarStorageKey("grammarHistory");
  if(!key) return;
  const raw = localStorage.getItem(key);
  const parsed = safeParse(raw, []);
  const questionCount = activeGrammarSet && Array.isArray(activeGrammarSet.questions) ? activeGrammarSet.questions.length : 0;
  grammarHistory = Array.isArray(parsed)
    ? parsed
        .map(entry => ({
          index: Number.isInteger(entry && entry.index) ? entry.index : -1,
          correct: Boolean(entry && entry.correct === true)
        }))
        .filter(entry => entry.index >= 0 && entry.index < questionCount)
    : [];
}


function updateTimerDisplay(labelEl, barEl, remainingMs, totalMs){
  if(labelEl){
    labelEl.style.display = 'flex';
    const seconds = Math.max(0, Math.ceil(remainingMs / 1000));
    labelEl.innerHTML = `剩余 <strong>${seconds} 秒</strong>`;
  }
  if(barEl){
    barEl.style.display = 'block';
    const span = barEl.querySelector('span');
    if(span){
      const ratio = totalMs > 0 ? Math.max(0, Math.min(1, remainingMs / totalMs)) : 0;
      span.style.transform = `scaleX(${ratio})`;
    }
  }
}

function hideTimer(labelEl, barEl){
  if(labelEl){
    labelEl.style.display = 'none';
  }
  if(barEl){
    barEl.style.display = 'none';
    const span = barEl.querySelector('span');
    if(span){
      span.style.transform = 'scaleX(1)';
    }
  }
}

function startWordTimer(){
  if(!wordTimerLabel || !wordTimerBar) return;
  stopWordTimer();
  const totalMs = WORD_TIME_LIMIT * 1000;
  wordTimerDeadline = Date.now() + totalMs;
  updateTimerDisplay(wordTimerLabel, wordTimerBar, totalMs, totalMs);
  wordTimerInterval = setInterval(() => {
    const remaining = wordTimerDeadline - Date.now();
    if(remaining <= 0){
      clearInterval(wordTimerInterval);
      wordTimerInterval = null;
      updateTimerDisplay(wordTimerLabel, wordTimerBar, 0, totalMs);
      handleWordTimeout();
    }else{
      updateTimerDisplay(wordTimerLabel, wordTimerBar, remaining, totalMs);
    }
  }, 100);
}

function stopWordTimer(){
  if(wordTimerInterval){
    clearInterval(wordTimerInterval);
    wordTimerInterval = null;
  }
  hideTimer(wordTimerLabel, wordTimerBar);
}

function handleWordTimeout(){
  if(wordQuestionGraded || !currentStudent || !activeWordBank) return;
  if(!wordSessionState || !Array.isArray(wordSessionState.indices) || !wordSessionState.indices.length) return;
  if(wordSessionState.pointer >= wordSessionState.indices.length) return;
  const currentIndex = wordSessionState.indices[wordSessionState.pointer];
  const currentItem = activeVocabulary[currentIndex];
  const gradeResult = gradeWordAnswer(-1, {autoTimeout: true, suppressAutoAdvance: true});
  const info = {
    word: currentItem && currentItem.word ? currentItem.word : "（未命名单词）",
    meaning: gradeResult && gradeResult.correctText ? gradeResult.correctText : getMeaningText(currentItem)
  };
  endWordSessionOnTimeout(info);
}

function startGrammarTimer(){
  if(!grammarTimerLabel || !grammarTimerBar) return;
  stopGrammarTimer();
  const totalMs = GRAMMAR_TIME_LIMIT * 1000;
  grammarTimerDeadline = Date.now() + totalMs;
  updateTimerDisplay(grammarTimerLabel, grammarTimerBar, totalMs, totalMs);
  grammarTimerInterval = setInterval(() => {
    const remaining = grammarTimerDeadline - Date.now();
    if(remaining <= 0){
      clearInterval(grammarTimerInterval);
      grammarTimerInterval = null;
      updateTimerDisplay(grammarTimerLabel, grammarTimerBar, 0, totalMs);
      handleGrammarTimeout();
    }else{
      updateTimerDisplay(grammarTimerLabel, grammarTimerBar, remaining, totalMs);
    }
  }, 100);
}

function stopGrammarTimer(){
  if(grammarTimerInterval){
    clearInterval(grammarTimerInterval);
    grammarTimerInterval = null;
  }
  hideTimer(grammarTimerLabel, grammarTimerBar);
}

function handleGrammarTimeout(){
  if(grammarQuestionGraded) return;
  gradeGrammarAnswer(null, {autoTimeout: true});
}

function startSentenceTimer(){
  if(!sentenceTimerLabel || !sentenceTimerBar) return;
  stopSentenceTimer();
  const totalMs = SENTENCE_TIME_LIMIT * 1000;
  sentenceTimerDeadline = Date.now() + totalMs;
  updateTimerDisplay(sentenceTimerLabel, sentenceTimerBar, totalMs, totalMs);
  sentenceTimerInterval = setInterval(() => {
    const remaining = sentenceTimerDeadline - Date.now();
    if(remaining <= 0){
      clearInterval(sentenceTimerInterval);
      sentenceTimerInterval = null;
      updateTimerDisplay(sentenceTimerLabel, sentenceTimerBar, 0, totalMs);
      handleSentenceTimeout();
    }else{
      updateTimerDisplay(sentenceTimerLabel, sentenceTimerBar, remaining, totalMs);
    }
  }, 100);
}

function stopSentenceTimer(){
  if(sentenceTimerInterval){
    clearInterval(sentenceTimerInterval);
    sentenceTimerInterval = null;
  }
  hideTimer(sentenceTimerLabel, sentenceTimerBar);
}

function handleSentenceTimeout(){
  if(sentenceLocked || !currentStudent || !activeSentenceSet) return;
  if(!sentenceSessionState || !Array.isArray(sentenceSessionState.indices) || !sentenceSessionState.indices.length) return;
  if(sentenceSessionState.pointer >= sentenceSessionState.indices.length) return;
  sentenceLocked = true;
  stopSentenceTimer();
  submitSentenceBtn.disabled = true;
  resetSentenceBtn.disabled = true;
  const currentIndex = sentenceSessionState.indices[sentenceSessionState.pointer];
  const originalSentence = sentenceOriginalTokens.join(' ').replace(/\s([.,!?;:])/g, '$1');
  sentenceAvailableTokens = [];
  sentenceSelectedTokens = sentenceOriginalTokens.map((text, idx) => ({text, index: idx, correctPlacement: true}));
  rebuildSentenceContainers();
  sentenceFeedback.textContent = `超时，正确顺序：${originalSentence}`;
  sentenceHistory.push({index: currentIndex, correct: false});
  const historyKey = sentenceStorageKey("sentenceHistory");
  if(historyKey) localStorage.setItem(historyKey, JSON.stringify(sentenceHistory));
  saveSentenceSessionState();
  renderOverallStats();
}

function updateSectionVisibility(){
  const currentParent = wordBankSelect ? wordBankSelect.value : "";
  const hasSubSelection = currentParent && Array.isArray(subWordBankMap[currentParent]) && subWordBankMap[currentParent].length;
  const showWordSection = Boolean(activeWordBank) || hasSubSelection;
  wordSection.style.display = showWordSection ? "" : "none";
  if(grammarSection){
    const showGrammar = Boolean(activeGrammarSet) || grammarBanks.length > 0;
    grammarSection.style.display = showGrammar ? "" : "none";
  }
  sentenceSection.style.display = activeSentenceSet ? "" : "none";
  updateWordControlsState();
  updateGrammarControlsState();
}

function updateWordControlsState(){
  if(!wordBatchSelect || !refreshWordSessionBtn) return;
  const enable = Boolean(currentStudent && activeWordBank);
  wordBatchSelect.disabled = !enable;
  refreshWordSessionBtn.disabled = !enable;
  if(wordSessionTypeSelect) wordSessionTypeSelect.disabled = !currentStudent;
  if(wordModeSelect) wordModeSelect.disabled = !currentStudent;
  if(wordLetterSelect){
    const parentId = wordBankSelect ? wordBankSelect.value : "";
    const banks = parentId && subWordBankMap[parentId] ? subWordBankMap[parentId] : [];
    if(banks.length){
      const currentValue = wordLetterSelect.value;
      populateSubBankSelect(parentId);
      if(activeWordBank && activeWordBank.parentId === parentId){
        wordLetterSelect.value = activeWordBank.id;
      }else if(currentValue && banks.some(bank => bank.id === currentValue)){
        wordLetterSelect.value = currentValue;
      }
    }else{
      populateSubBankSelect();
    }
  }
}

function updateGrammarControlsState(){
  if(!grammarBatchSelect || !startGrammarSessionBtn) return;
  const enable = Boolean(currentStudent && activeGrammarSet);
  grammarBatchSelect.disabled = !enable;
  startGrammarSessionBtn.disabled = !enable;
  if(submitGrammarBtn) submitGrammarBtn.disabled = true;
  if(nextGrammarBtn) nextGrammarBtn.disabled = !enable;
}

function activateWordBank(bankId){
  stopWordTimer();
  if(!bankId){
    activeWordBank = null;
    activeVocabulary = [];
    currentVocabIndex = 0;
    wordHistory = [];
    wordSessionState = null;
    unfamiliarIndices = new Set();
  }else{
    const nextBank = wordBanks.find(bank => bank.id === bankId);
    if(!nextBank){
      activeWordBank = null;
      activeVocabulary = [];
      currentVocabIndex = 0;
      wordHistory = [];
      wordSessionState = null;
      unfamiliarIndices = new Set();
    }else{
      activeWordBank = nextBank;
      activeVocabulary = nextBank.items;
      wordSessionState = null;
      wordPracticeMode = wordModeSelect && wordModeSelect.value === "review" ? "review" : "normal";
      if(nextBank.parentId && wordLetterSelect){
        if(wordBankSelect && wordBankSelect.value !== nextBank.parentId){
          wordBankSelect.value = nextBank.parentId;
        }
        populateSubBankSelect(nextBank.parentId);
        wordLetterSelect.style.display = "";
        wordLetterSelect.disabled = false;
        wordLetterSelect.value = nextBank.id;
      }else if(wordLetterSelect){
        populateSubBankSelect();
        wordLetterSelect.value = "";
      }
      if(currentStudent){
        loadWordProgress();
      }else{
        currentVocabIndex = 0;
        wordHistory = [];
        unfamiliarIndices = new Set();
      }
    }
  }
  renderWordQuestion();
  renderOverallStats();
  updateSectionVisibility();
}

function activateGrammarSet(setId){
  stopGrammarTimer();
  if(grammarAutoAdvanceTimer){
    clearTimeout(grammarAutoAdvanceTimer);
    grammarAutoAdvanceTimer = null;
  }
  if(!setId){
    activeGrammarSet = null;
    grammarSessionState = null;
    grammarHistory = [];
    grammarCurrentOptions = [];
    grammarSelectedOptionKey = null;
    grammarQuestionGraded = false;
    grammarSessionNeedsStart = true;
  }else{
    const nextSet = grammarBanks.find(bank => bank.id === setId);
    if(!nextSet){
      activeGrammarSet = null;
      grammarSessionState = null;
      grammarHistory = [];
      grammarCurrentOptions = [];
      grammarSelectedOptionKey = null;
      grammarQuestionGraded = false;
      grammarSessionNeedsStart = true;
    }else{
      activeGrammarSet = nextSet;
      grammarSessionState = null;
      grammarCurrentOptions = [];
      grammarSelectedOptionKey = null;
      grammarQuestionGraded = false;
      grammarSessionNeedsStart = true;
      if(currentStudent){
        loadGrammarHistory();
      }else{
        grammarHistory = [];
      }
      if(grammarBatchSelect){
        const defaultValue = Array.from(grammarBatchSelect.options).some(opt => opt.value === "20") ? "20" : grammarBatchSelect.options[0]?.value || "all";
        grammarBatchSelect.value = defaultValue;
      }
    }
  }
  renderGrammarQuestion();
  renderOverallStats();
  updateSectionVisibility();
}

function activateSentenceSet(setId){
  stopSentenceTimer();
  if(!setId){
    activeSentenceSet = null;
    currentSentenceIndex = 0;
    sentenceHistory = [];
    sentenceSessionState = null;
    saveSentenceSessionState();
    sentenceAvailableTokens = [];
    sentenceSelectedTokens = [];
    sentenceOriginalTokens = [];
    sentenceLocked = false;
  }else{
    const nextSet = sentenceSets.find(set => set.id === setId);
    if(!nextSet){
      activeSentenceSet = null;
      currentSentenceIndex = 0;
      sentenceHistory = [];
      sentenceAvailableTokens = [];
      sentenceSelectedTokens = [];
      sentenceOriginalTokens = [];
      sentenceLocked = false;
      sentenceSessionState = null;
    }else{
      activeSentenceSet = nextSet;
      if(currentStudent){
        loadSentenceProgress();
      }else{
        currentSentenceIndex = 0;
        sentenceHistory = [];
        sentenceSessionState = null;
      }
      sentenceAvailableTokens = [];
      sentenceSelectedTokens = [];
      sentenceOriginalTokens = [];
      sentenceLocked = false;
    }
  }
  renderSentenceQuestion();
  renderOverallStats();
  updateSectionVisibility();
}

function loadStudent(){
  stopWordTimer();
  stopGrammarTimer();
  stopSentenceTimer();
  currentStudent = studentSelect.value;
  if(!currentStudent){
    wordHistory = [];
    sentenceHistory = [];
    sentenceSessionState = null;
    grammarHistory = [];
    grammarSessionState = null;
    grammarSessionNeedsStart = true;
  }else{
    if(activeWordBank){
      loadWordProgress();
    }
    if(activeSentenceSet){
      loadSentenceProgress();
    }
    if(activeGrammarSet){
      loadGrammarHistory();
    }
  }
  renderWordQuestion();
  renderGrammarQuestion();
  renderSentenceQuestion();
  renderOverallStats();
  updateSectionVisibility();
}
studentSelect.addEventListener("change", () => {
  if(currentStudent){
    handleWordSessionQuit("switch-student");
  }
  loadStudent();
});

wordBankSelect.addEventListener("change", () => {
  const selectedId = wordBankSelect.value;

  if(activeWordBank){
    handleWordSessionQuit("switch-bank");
  }

  if(grammarSetSelect && grammarSetSelect.value){
    grammarSetSelect.value = "";
  }
  if(activeGrammarSet){
    activateGrammarSet(null);
  }

  const hasSubBanks = selectedId && Array.isArray(subWordBankMap[selectedId]) && subWordBankMap[selectedId].length;

  if(hasSubBanks){
    activateWordBank(null);
    if(wordLetterSelect){
      populateSubBankSelect(selectedId);
      wordLetterSelect.value = "";
      wordLetterSelect.style.display = "";
      wordLetterSelect.disabled = false;
    }
    updateWordControlsState();
    renderWordQuestion();
    return;
  }

  if(wordLetterSelect){
    populateSubBankSelect();
    wordLetterSelect.value = "";
    wordLetterSelect.style.display = "none";
    wordLetterSelect.disabled = true;
  }

  if(selectedId){
    if(activeSentenceSet){
      sentenceSetSelect.value = "";
      activateSentenceSet(null);
    }
    if(activeGrammarSet){
      activateGrammarSet(null);
    }
    activateWordBank(selectedId);
  }else{
    activateWordBank(null);
  }
  updateWordControlsState();
  updateGrammarControlsState();
});

if(wordLetterSelect){
  wordLetterSelect.addEventListener("change", () => {
    const letterBankId = wordLetterSelect.value;
    if(activeWordBank && activeWordBank.id !== letterBankId){
      handleWordSessionQuit("switch-bank");
    }
    if(!letterBankId){
      activateWordBank(null);
      updateWordControlsState();
      renderWordQuestion();
      return;
    }
    if(activeSentenceSet){
      sentenceSetSelect.value = "";
      activateSentenceSet(null);
    }
    if(activeGrammarSet){
      grammarSetSelect.value = "";
      activateGrammarSet(null);
    }
    const subBank = wordBanks.find(bank => bank.id === letterBankId);
    const parentId = subBank && subBank.parentId;
    if(parentId && wordBankSelect && wordBankSelect.value !== parentId){
      wordBankSelect.value = parentId;
    }
    activateWordBank(letterBankId);
    updateWordControlsState();
  });
}

if(grammarSetSelect){
  grammarSetSelect.addEventListener("change", () => {
    const selectedId = grammarSetSelect.value;
    if(selectedId){
      if(activeWordBank){
        handleWordSessionQuit("switch-to-grammar");
      }
      if(wordBankSelect){
        wordBankSelect.value = "";
      }
      if(wordLetterSelect){
        populateSubBankSelect();
        wordLetterSelect.value = "";
        wordLetterSelect.style.display = "none";
        wordLetterSelect.disabled = true;
      }
      activateWordBank(null);
      if(activeSentenceSet){
        sentenceSetSelect.value = "";
        activateSentenceSet(null);
      }
      activateGrammarSet(selectedId);
    }else{
      activateGrammarSet(null);
    }
    updateGrammarControlsState();
  });
}

sentenceSetSelect.addEventListener("change", () => {
  const selectedId = sentenceSetSelect.value;
  if(selectedId){
    if(activeWordBank){
      handleWordSessionQuit("switch-to-sentence");
      wordBankSelect.value = "";
      if(wordLetterSelect){
        wordLetterSelect.value = "";
        wordLetterSelect.style.display = "none";
        wordLetterSelect.disabled = true;
      }
      activateWordBank(null);
    }
    if(activeGrammarSet){
      grammarSetSelect.value = "";
      activateGrammarSet(null);
    }
    activateSentenceSet(selectedId);
  }else{
    activateSentenceSet(null);
  }
});

if(wordBatchSelect){
  wordBatchSelect.addEventListener("change", () => {
    const size = Number(wordBatchSelect.value) || DEFAULT_WORD_BATCH;
    if(wordSessionState){
      wordSessionState.batchSize = size;
      saveWordSessionState();
    }
  });
}

if(wordSessionTypeSelect){
  wordSessionTypeSelect.addEventListener("change", () => {
    wordSessionType = wordSessionTypeSelect.value === "exam" ? "exam" : "practice";
    if(wordSessionState){
      wordSessionState.sessionType = wordSessionType;
      if(wordSessionType === "exam"){
        wordSessionState.scoreApplied = false;
      }
      saveWordSessionState();
    }
    renderWordQuestion();
  });
}

if(wordModeSelect){
  wordModeSelect.addEventListener("change", () => {
    wordPracticeMode = wordModeSelect.value === "review" ? "review" : "normal";
    if(wordSessionState){
      wordSessionState.mode = wordPracticeMode;
      saveWordSessionState();
    }
    renderWordQuestion();
  });
}

if(refreshWordSessionBtn){
  refreshWordSessionBtn.addEventListener("click", () => {
    if(!currentStudent){
      alert("请先选择学生");
      return;
    }
    if(!activeWordBank){
      alert("请选择词库后再生成测验");
      return;
    }
    const hasSessionToResume = Boolean(
      wordSessionNeedsStart &&
      wordSessionState &&
      Array.isArray(wordSessionState.indices) &&
      wordSessionState.indices.length
    );
    if(hasSessionToResume){
      wordPracticeMode = wordSessionState.mode === "review" ? "review" : "normal";
      if(wordModeSelect) wordModeSelect.value = wordPracticeMode;
      if(wordBatchSelect){
        const batchSize = Number.isFinite(wordSessionState.batchSize) && wordSessionState.batchSize > 0
          ? wordSessionState.batchSize
          : DEFAULT_WORD_BATCH;
        wordBatchSelect.value = String(batchSize);
      }
      const sessionTypeToResume = wordSessionState.sessionType === "practice" ? "practice" : "exam";
      wordSessionType = sessionTypeToResume;
      if(wordSessionTypeSelect) wordSessionTypeSelect.value = sessionTypeToResume;
      wordSessionNeedsStart = false;
      renderWordQuestion();
      return;
    }
    const size = Number(wordBatchSelect && wordBatchSelect.value) || DEFAULT_WORD_BATCH;
    wordPracticeMode = wordModeSelect && wordModeSelect.value === "review" ? "review" : "normal";
    wordSessionType = wordSessionTypeSelect && wordSessionTypeSelect.value === "exam" ? "exam" : "practice";
    startNewWordSession(size);
  });
}

if(startGrammarSessionBtn){
  startGrammarSessionBtn.addEventListener("click", () => {
    if(!currentStudent){
      alert("请先选择学生");
      return;
    }
    if(!activeGrammarSet){
      alert("请选择语法题库后再生成练习");
      return;
    }
    const rawValue = grammarBatchSelect ? grammarBatchSelect.value : "all";
    const total = activeGrammarSet ? activeGrammarSet.questions.length : 0;
    const size = rawValue === "all" ? total : (Number(rawValue) || total);
    startNewGrammarSession(size);
  });
}

if(submitGrammarBtn){
  submitGrammarBtn.style.display = "none";
}

if(nextGrammarBtn){
  nextGrammarBtn.addEventListener("click", () => {
    advanceGrammarPointer({auto: false});
  });
}

function startNewWordSession(requestedSize){
  stopWordTimer();
  handleWordSessionQuit("restart");

  if(!activeWordBank){
    wordSessionState = null;
    saveWordSessionState();
    renderWordQuestion();
    return;
  }

  const totalWords = activeVocabulary.length;
  const batchSize = Number.isFinite(requestedSize) && requestedSize > 0 ? requestedSize : DEFAULT_WORD_BATCH;
  const prioritized = buildPrioritizedWordIndices(totalWords, wordPracticeMode);
  const sliceLength = Math.min(batchSize, prioritized.length);
  const indices = sliceLength > 0 ? prioritized.slice(0, sliceLength) : prioritized.slice();

  wordSessionState = {
    batchSize,
    indices,
    pointer: 0,
    mode: wordPracticeMode,
    sessionType: wordSessionType,
    answers: [],
    scoreApplied: false
  };

  if(wordBatchSelect) wordBatchSelect.value = String(batchSize);
  if(wordModeSelect) wordModeSelect.value = wordPracticeMode;
  if(wordSessionTypeSelect) wordSessionTypeSelect.value = wordSessionType;

  saveWordSessionState();
  wordSessionNeedsStart = false;
  renderWordQuestion();
  renderOverallStats();
}

function saveWordSessionState(){
  const key = storageKey("wordSession");
  if(!key) return;
  if(!wordSessionState){
    localStorage.removeItem(key);
    return;
  }
  const payload = {
    batchSize: wordSessionState.batchSize,
    indices: wordSessionState.indices,
    pointer: wordSessionState.pointer,
    mode: wordSessionState.mode || "normal",
    sessionType: wordSessionState.sessionType === "exam" ? "exam" : "practice",
    answers: Array.isArray(wordSessionState.answers) ? wordSessionState.answers : [],
    scoreApplied: Boolean(wordSessionState.scoreApplied)
  };
  localStorage.setItem(key, JSON.stringify(payload));
}

function buildPrioritizedWordIndices(totalWords, mode){
  if(!Number.isInteger(totalWords) || totalWords <= 0) return [];
  const unfamiliarList = Array.from(unfamiliarIndices)
    .filter(idx => Number.isInteger(idx) && idx >= 0 && idx < totalWords);
  const lastAttemptMap = new Map();
  wordHistory.forEach(entry => {
    if(entry && Number.isInteger(entry.index) && entry.index >= 0 && entry.index < totalWords){
      lastAttemptMap.set(entry.index, entry.correct);
    }
  });

  const untested = [];
  const needsReview = [];
  const mastered = [];

  for(let i = 0; i < totalWords; i++){
    if(!lastAttemptMap.has(i)){
      untested.push(i);
    }else if(lastAttemptMap.get(i)){
      mastered.push(i);
    }else{
      needsReview.push(i);
    }
  }

  const prioritized = [];
  const seen = new Set();
  const pushList = list => {
    list.forEach(idx => {
      if(!seen.has(idx)){
        seen.add(idx);
        prioritized.push(idx);
      }
    });
  };

  if(mode === "review"){
    if(unfamiliarList.length){
      pushList(shuffleArray(unfamiliarList));
      return prioritized;
    }
    pushList(shuffleArray(needsReview));
    pushList(shuffleArray(untested));
    pushList(shuffleArray(mastered));
    return prioritized;
  }

  pushList(shuffleArray(unfamiliarList));
  pushList(shuffleArray(untested));
  pushList(shuffleArray(needsReview));
  pushList(shuffleArray(mastered));
  return prioritized;
}

function loadWordScoreboard(){
  const parsed = safeParse(localStorage.getItem(WORD_SCORE_STORAGE_KEY), {});
  if(!parsed || typeof parsed !== "object") return {};
  const scoreboard = {};
  Object.keys(parsed).forEach(student => {
    const entry = parsed[student];
    if(!entry || typeof entry !== "object") return;
    const total = Number(entry.total);
    let reward = Number(entry.reward);
    let penalty = Number(entry.penalty);
    let redeemable = Number(entry.redeemable);
    const history = Array.isArray(entry.history)
      ? entry.history
          .map(item => {
            if(!item || typeof item !== "object") return null;
            const delta = Number(item.delta);
            const batchSize = Number(item.batchSize);
            const correctCount = Number(item.correctCount);
            const totalCount = Number(item.totalCount);
            const answeredCount = Number.isFinite(Number(item.answeredCount)) ? Number(item.answeredCount) : totalCount;
            const accuracy = Number(item.accuracy);
            const timestamp = Number(item.timestamp);
            if(!Number.isFinite(delta) || !Number.isFinite(timestamp)) return null;
            return {
              delta,
              outcome: typeof item.outcome === "string" ? item.outcome : "neutral",
              batchSize: Number.isFinite(batchSize) ? batchSize : 0,
              correctCount: Number.isFinite(correctCount) ? correctCount : 0,
              totalCount: Number.isFinite(totalCount) ? totalCount : 0,
              answeredCount: Number.isFinite(answeredCount) ? answeredCount : 0,
              accuracy: Number.isFinite(accuracy) ? accuracy : 0,
              mode: item.mode === "review" ? "review" : "normal",
              reason: typeof item.reason === "string" ? item.reason : "",
              redeemed: Number.isFinite(item.redeemed) ? Math.max(0, item.redeemed) : 0,
              timestamp
            };
          })
          .filter(Boolean)
          .sort((a, b) => b.timestamp - a.timestamp)
      : [];
    if(!Number.isFinite(reward) || !Number.isFinite(penalty)){
      reward = 0;
      penalty = 0;
      history.forEach(record => {
        if(!record || !Number.isFinite(record.delta)) return;
        if(record.delta > 0){
          reward += record.delta;
        }else if(record.delta < 0){
          penalty += record.delta;
        }
      });
    }
    let normalizedTotal = Number.isFinite(total) ? total : reward + penalty;
    if(!Number.isFinite(normalizedTotal)) normalizedTotal = reward + penalty;
    if(Math.abs(normalizedTotal - (reward + penalty)) > 0.0001){
      normalizedTotal = reward + penalty;
    }
    const computedRedeemable = Number.isFinite(redeemable)
      ? Math.max(0, redeemable)
      : Math.max(0, reward + penalty);
    scoreboard[student] = {
      total: normalizedTotal,
      reward,
      penalty,
      redeemable: computedRedeemable,
      history: history.slice(0, 30)
    };
  });
  return scoreboard;
}

function saveWordScoreboard(){
  if(!wordScoreboard || typeof wordScoreboard !== "object"){
    localStorage.removeItem(WORD_SCORE_STORAGE_KEY);
    wordScoreboard = {};
    return;
  }
  const payload = {};
  Object.keys(wordScoreboard).forEach(student => {
    const entry = wordScoreboard[student];
    if(!entry || typeof entry !== "object") return;
    const total = Number(entry.total);
    const reward = Number(entry.reward);
    const penalty = Number(entry.penalty);
    const redeemable = Number(entry.redeemable);
    const history = Array.isArray(entry.history) ? entry.history.filter(Boolean) : [];
    const hasScore = (Number.isFinite(reward) && reward !== 0) || (Number.isFinite(penalty) && penalty !== 0) || (Number.isFinite(total) && total !== 0) || (Number.isFinite(redeemable) && redeemable !== 0) || history.length;
    if(!history.length && !hasScore) return;
    payload[student] = {
      total: Number.isFinite(total) ? total : (Number.isFinite(reward) || Number.isFinite(penalty) ? (Number.isFinite(reward) ? reward : 0) + (Number.isFinite(penalty) ? penalty : 0) : 0),
      reward: Number.isFinite(reward) ? reward : 0,
      penalty: Number.isFinite(penalty) ? penalty : 0,
      redeemable: Number.isFinite(redeemable) ? Math.max(0, redeemable) : Math.max(0, (Number.isFinite(reward) ? reward : 0) + (Number.isFinite(penalty) ? penalty : 0)),
      history
    };
  });
  const keys = Object.keys(payload);
  if(keys.length === 0){
    localStorage.removeItem(WORD_SCORE_STORAGE_KEY);
    wordScoreboard = {};
    return;
  }
  wordScoreboard = payload;
  localStorage.setItem(WORD_SCORE_STORAGE_KEY, JSON.stringify(payload));
}

function getWordScoreData(student){
  if(!student) return {total: 0, reward: 0, penalty: 0, redeemable: 0, history: []};
  const entry = wordScoreboard && wordScoreboard[student];
  if(!entry) return {total: 0, reward: 0, penalty: 0, redeemable: 0, history: []};
  const reward = Number(entry.reward);
  const penalty = Number(entry.penalty);
  const total = Number(entry.total);
  const redeemable = Number(entry.redeemable);
  const history = Array.isArray(entry.history) ? entry.history.slice() : [];
  const normalizedReward = Number.isFinite(reward) ? reward : 0;
  const normalizedPenalty = Number.isFinite(penalty) ? penalty : 0;
  const normalizedRedeemable = Number.isFinite(redeemable) ? Math.max(0, redeemable) : Math.max(0, normalizedReward + normalizedPenalty);
  return {
    total: normalizedReward + normalizedPenalty,
    reward: normalizedReward,
    penalty: normalizedPenalty,
    redeemable: normalizedRedeemable,
    history
  };
}

function applyWordScoreChange(student, delta, detail){
  if(!student || !Number.isFinite(delta)) return null;
  if(!wordScoreboard || typeof wordScoreboard !== "object") wordScoreboard = {};
  const existing = wordScoreboard[student] || {...SCORE_DEFAULTS};
  const previousReward = Number(existing.reward);
  const previousPenalty = Number(existing.penalty);
  const previousRedeemable = Number(existing.redeemable);
  const baseReward = Number.isFinite(previousReward) ? previousReward : 0;
  const basePenalty = Number.isFinite(previousPenalty) ? previousPenalty : 0;
  const baseRedeemable = Number.isFinite(previousRedeemable) ? Math.max(0, previousRedeemable) : Math.max(0, baseReward + basePenalty);
  const nextReward = delta > 0 ? baseReward + delta : baseReward;
  const nextPenalty = delta < 0 ? basePenalty + delta : basePenalty;
  const nextTotal = nextReward + nextPenalty;
  let nextRedeemable = baseRedeemable;
  if(delta > 0){
    nextRedeemable = baseRedeemable + delta;
  }else if(delta < 0){
    nextRedeemable = Math.max(0, baseRedeemable + delta);
  }
  const historyEntry = {
    delta,
    outcome: detail && typeof detail.outcome === "string" ? detail.outcome : "neutral",
    batchSize: detail && Number.isFinite(detail.batchSize) ? detail.batchSize : 0,
    correctCount: detail && Number.isFinite(detail.correctCount) ? detail.correctCount : 0,
    totalCount: detail && Number.isFinite(detail.totalCount) ? detail.totalCount : 0,
    answeredCount: detail && Number.isFinite(detail.answeredCount)
      ? detail.answeredCount
      : detail && Number.isFinite(detail.totalCount)
        ? detail.totalCount
        : 0,
    accuracy: detail && Number.isFinite(detail.accuracy) ? detail.accuracy : 0,
    mode: detail && detail.mode === "review" ? "review" : "normal",
    reason: detail && typeof detail.reason === "string" ? detail.reason : "",
    timestamp: Date.now()
  };
  existing.total = nextTotal;
  existing.reward = nextReward;
  existing.penalty = nextPenalty;
  existing.redeemable = nextRedeemable;
  const history = Array.isArray(existing.history) ? existing.history : [];
  existing.history = [historyEntry, ...history].slice(0, 30);
  wordScoreboard[student] = existing;
  saveWordScoreboard();
  renderOverallStats();
  return {total: nextTotal, reward: nextReward, penalty: nextPenalty, redeemable: nextRedeemable, record: historyEntry};
}

function redeemStudentScore(student, options = {}){
  if(!student || !wordScoreboard || typeof wordScoreboard !== "object") return null;
  const entry = wordScoreboard[student];
  if(!entry || typeof entry !== "object") return null;
  const baseRedeemable = Number(entry.redeemable);
  const currentRedeemable = Number.isFinite(baseRedeemable) ? Math.max(0, baseRedeemable) : 0;
  const requested = Number(options.amount);
  const redemption = Number.isFinite(requested) && requested > 0
    ? Math.min(requested, currentRedeemable)
    : currentRedeemable;
  if(redemption <= 0) return null;

  entry.redeemable = Math.max(0, currentRedeemable - redemption);
  const history = Array.isArray(entry.history) ? entry.history : [];
  const historyEntry = {
    delta: 0,
    outcome: "redeem",
    redeemed: redemption,
    batchSize: 0,
    correctCount: 0,
    totalCount: 0,
    answeredCount: 0,
    accuracy: 0,
    mode: "normal",
    reason: options.reason || "redeem",
    timestamp: Date.now()
  };
  entry.history = [historyEntry, ...history].slice(0, 30);
  wordScoreboard[student] = entry;
  saveWordScoreboard();
  renderOverallStats();
  const message = buildWordScoreFeedbackMessage(historyEntry, Number(entry.total) || 0, Number(entry.redeemable));
  if(options.broadcast !== false){
    broadcastWordScoreMessage(message);
  }
  return {
    total: Number(entry.total) || 0,
    reward: Number(entry.reward) || 0,
    penalty: Number(entry.penalty) || 0,
    redeemable: Number(entry.redeemable) || 0,
    record: historyEntry
  };
}

window.redeemWordScore = redeemStudentScore;

function formatPercentage(value){
  if(!Number.isFinite(value) || value <= 0) return "0%";
  const scaled = Math.round(value * 1000) / 10;
  return Number.isInteger(scaled) ? `${scaled.toFixed(0)}%` : `${scaled.toFixed(1)}%`;
}

function formatScoreDelta(delta){
  if(!Number.isFinite(delta) || delta === 0) return "0";
  return delta > 0 ? `+${delta}` : `${delta}`;
}

function formatWordScoreHistoryLabel(record){
  if(!record) return "暂无积分记录";
  if(record.outcome === "redeem"){
    const amount = Number.isFinite(record.redeemed) ? Math.max(0, record.redeemed) : 0;
    return `兑换积分 ${amount} 分`;
  }
  const batchLabel = record.batchSize ? `${record.batchSize}题` : "--";
  const modeLabel = record.mode === "review" ? "（错词强化）" : "";
  switch(record.outcome){
    case "timeout":
      return `${batchLabel}${modeLabel} 超时终止`;
    case "quit": {
      const answeredText = Number.isFinite(record.answeredCount) && record.answeredCount > 0
        ? `（已答 ${record.correctCount}/${record.answeredCount}）`
        : "";
      return `${batchLabel}${modeLabel} 中途退出${answeredText}`;
    }
    case "full":
      return `${batchLabel}${modeLabel} 全对`;
    case "low-accuracy":
    case "neutral":
      return `${batchLabel}${modeLabel} 正确率 ${formatPercentage(record.accuracy)}`;
    default:
      return `${batchLabel}${modeLabel}`;
  }
}

function buildWordSessionScoreResult(batchSize, correctCount, totalCount, isQuit, answeredCount, mode){
  const rules = WORD_SCORE_RULES[batchSize];
  if(!rules) return null;
  const plannedTotal = Number.isFinite(totalCount) ? totalCount : batchSize;
  const answered = Number.isFinite(answeredCount) ? answeredCount : plannedTotal;
  const accuracyBase = isQuit ? answered : plannedTotal;
  const accuracy = accuracyBase > 0 ? correctCount / accuracyBase : 0;

  if(isQuit){
    return {
      delta: rules.quit,
      outcome: "quit",
      batchSize,
      correctCount,
      totalCount: plannedTotal,
      answeredCount: answered,
      accuracy,
      mode: mode === "review" ? "review" : "normal"
    };
  }

  if(plannedTotal <= 0) return null;

  if(correctCount >= plannedTotal){
    return {
      delta: rules.fullBonus,
      outcome: "full",
      batchSize,
      correctCount,
      totalCount: plannedTotal,
      answeredCount: plannedTotal,
      accuracy: 1,
      mode: mode === "review" ? "review" : "normal"
    };
  }

  if(accuracy < rules.penaltyThreshold){
    return {
      delta: rules.penalty,
      outcome: "low-accuracy",
      batchSize,
      correctCount,
      totalCount: plannedTotal,
      answeredCount: plannedTotal,
      accuracy,
      mode: mode === "review" ? "review" : "normal"
    };
  }

  return {
    delta: 0,
    outcome: "neutral",
    batchSize,
    correctCount,
    totalCount: plannedTotal,
    answeredCount: plannedTotal,
    accuracy,
    mode: mode === "review" ? "review" : "normal"
  };
}

function buildWordScoreFeedbackMessage(record, totalScore, redeemableScore){
  if(!record) return "";
  const batchLabel = record.batchSize ? `${record.batchSize}题` : "本次";
  const modeLabel = record.mode === "review" ? "（错词强化）" : "";
  const percentageText = formatPercentage(record.accuracy);
  const absoluteDelta = Math.abs(record.delta);
  switch(record.outcome){
    case "redeem": {
      const amount = Number.isFinite(record.redeemed) ? Math.max(0, record.redeemed) : 0;
      const remaining = Number.isFinite(redeemableScore) ? Math.max(0, redeemableScore) : 0;
      return `成功兑换 ${amount} 分，可兑换积分剩余 ${remaining} 分。`;
    }
    case "timeout":
      return `${batchLabel}${modeLabel}测验超时，扣除 ${absoluteDelta} 分。当前积分 ${totalScore} 分。`;
    case "quit":
      return `${batchLabel}${modeLabel}练习中途退出，扣除 ${absoluteDelta} 分。当前积分 ${totalScore} 分。`;
    case "full":
      return `${batchLabel}${modeLabel}练习全对，奖励 +${absoluteDelta} 分！当前积分 ${totalScore} 分。`;
    case "low-accuracy":
      return `${batchLabel}${modeLabel}练习正确率 ${percentageText}，扣除 ${absoluteDelta} 分。当前积分 ${totalScore} 分。`;
    case "neutral":
      return `${batchLabel}${modeLabel}练习正确率 ${percentageText}，积分保持不变（当前 ${totalScore} 分）。`;
    default:
      return `${batchLabel}${modeLabel}练习积分变动 ${formatScoreDelta(record.delta)}，当前积分 ${totalScore} 分。`;
  }
}

function broadcastWordScoreMessage(message){
  if(!message || !wordFeedback) return;
  wordFeedback.textContent = wordFeedback.textContent
    ? `${wordFeedback.textContent} ｜ ${message}`
    : message;
}

function collectWordSessionAnswers(totalPlanned){
  const map = new Map();
  if(!wordSessionState || !Array.isArray(wordSessionState.answers)) return map;
  wordSessionState.answers.forEach(entry => {
    if(!entry || typeof entry !== "object") return;
    const idx = Number(entry.index);
    if(!Number.isInteger(idx) || idx < 0 || idx >= totalPlanned) return;
    map.set(idx, Boolean(entry.correct));
  });
  return map;
}

function finalizeWordSessionScore(result){
  if(!currentStudent || !wordSessionState || !result) return;
  if(!isExamWordSession()){
    completePracticeSession();
    return;
  }
  const applied = applyWordScoreChange(currentStudent, Number(result.delta) || 0, result);
  wordSessionState.scoreApplied = true;
  if(wordSessionState && Array.isArray(wordSessionState.indices)){
    const size = wordSessionState.indices.length;
    if(Number.isInteger(wordSessionState.pointer)){
      wordSessionState.pointer = Math.max(wordSessionState.pointer, size);
    }
  }
  saveWordSessionState();
  if(applied && applied.record){
    const message = buildWordScoreFeedbackMessage(applied.record, Number(applied.total) || 0, Number(applied.redeemable));
    broadcastWordScoreMessage(message);
  }
}

function evaluateWordSessionCompletion(){
  if(!currentStudent || !wordSessionState || wordSessionState.scoreApplied) return;
  const plannedTotal = Array.isArray(wordSessionState.indices) ? wordSessionState.indices.length : 0;
  if(plannedTotal === 0) return;
  const answersMap = collectWordSessionAnswers(plannedTotal);
  if(answersMap.size < plannedTotal) return;
  if(!isExamWordSession()){
    completePracticeSession("练习模式完成，不计积分。");
    renderOverallStats();
    return;
  }
  let correctCount = 0;
  answersMap.forEach(value => {
    if(value) correctCount++;
  });
  const result = buildWordSessionScoreResult(
    wordSessionState.batchSize,
    correctCount,
    plannedTotal,
    false,
    plannedTotal,
    wordSessionState.mode || "normal"
  );
  if(result){
    result.reason = "complete";
    finalizeWordSessionScore(result);
  }
}

function handleWordSessionQuit(reason){
  stopWordTimer();
  if(!currentStudent || !wordSessionState || wordSessionState.scoreApplied) return;
  const plannedTotal = Array.isArray(wordSessionState.indices) ? wordSessionState.indices.length : 0;
  if(plannedTotal === 0) return;
  const answersMap = collectWordSessionAnswers(plannedTotal);
  if(answersMap.size === 0) return;

  if(!isExamWordSession()){
    completePracticeSession(null);
    renderOverallStats();
    return;
  }

  let correctCount = 0;
  answersMap.forEach(value => {
    if(value) correctCount++;
  });
  const answeredCount = answersMap.size;
  const isQuit = answeredCount < plannedTotal;
  const result = buildWordSessionScoreResult(
    wordSessionState.batchSize,
    correctCount,
    plannedTotal,
    isQuit,
    answeredCount,
    wordSessionState.mode || "normal"
  );
  if(result){
    result.reason = reason || (isQuit ? "quit" : "complete");
    finalizeWordSessionScore(result);
  }
}

function getCurrentWordIndexFromSession(){
  if(!wordSessionState || !wordSessionState.indices.length) return null;
  const pointer = Math.min(Math.max(wordSessionState.pointer, 0), wordSessionState.indices.length);
  if(pointer >= wordSessionState.indices.length) return null;
  return wordSessionState.indices[pointer];
}

function getSessionDisplaySizes(){
  const sessionSize = wordSessionState ? wordSessionState.indices.length : 0;
  const batchTarget = wordSessionState
    ? wordSessionState.batchSize
    : Number(wordBatchSelect && wordBatchSelect.value) || DEFAULT_WORD_BATCH;
  return {sessionSize, batchTarget};
}

function renderWordQuestion(){
  stopWordTimer();
  wordOptionsContainer.innerHTML = "";
  wordFeedback.textContent = "";
  exampleDisplay.textContent = "";
  selectedWordOptionIndex = null;
  wordQuestionGraded = false;

  const wordBankName = activeWordBank
    ? activeWordBank.name
    : (() => {
        const parentId = wordBankSelect ? wordBankSelect.value : "";
        if(parentId && Array.isArray(subWordBankMap[parentId]) && subWordBankMap[parentId].length){
          const parentBank = topLevelWordBanks.find(bank => bank.id === parentId);
          return parentBank ? parentBank.name : "未选择词库";
        }
        return "未选择词库";
      })();
  const activeMode = wordSessionState ? (wordSessionState.mode || "normal") : wordPracticeMode;
  const activeSessionType = wordSessionState ? (wordSessionState.sessionType || wordSessionType) : wordSessionType;
  const sessionTypeLabel = getWordSessionTypeLabel(activeSessionType);
  const modeLabel = activeMode === "review" ? "错词强化" : "正常练习";
  const modeSummary = `${sessionTypeLabel} · ${modeLabel}`;

  if(!currentStudent){
    vocabProgress.textContent = `词库：${wordBankName}`;
    wordDisplay.textContent = "请先选择学生";
    wordPrompt.textContent = "";
    if(submitWordBtn) submitWordBtn.disabled = true;
    if(nextWordBtn) nextWordBtn.disabled = true;
    return;
  }

  if(!activeWordBank){
    if(wordBankSelect && Array.isArray(subWordBankMap[wordBankSelect.value]) && subWordBankMap[wordBankSelect.value].length){
      const parentName = topLevelWordBanks.find(bank => bank.id === wordBankSelect.value);
      const parentLabel = parentName ? parentName.name : "子词库";
      vocabProgress.textContent = `词库：${parentLabel} | 请选择子词库`;
      wordDisplay.textContent = "请选择子词库开始单词测验";
      wordPrompt.textContent = "";
    }else{
      vocabProgress.textContent = "词库：未选择";
      wordDisplay.textContent = "请选择词库开始单词测验";
      wordPrompt.textContent = "";
    }
    if(submitWordBtn) submitWordBtn.disabled = true;
    if(nextWordBtn) nextWordBtn.disabled = true;
    return;
  }

  const totalWords = activeVocabulary.length;
  if(totalWords === 0){
    vocabProgress.textContent = `词库：${wordBankName}`;
    wordDisplay.textContent = "当前词库暂无单词";
    wordPrompt.textContent = "";
    if(submitWordBtn) submitWordBtn.disabled = true;
    if(nextWordBtn) nextWordBtn.disabled = true;
    return;
  }

  const {sessionSize, batchTarget} = getSessionDisplaySizes();
  const pointer = wordSessionState ? Math.min(Math.max(wordSessionState.pointer, 0), sessionSize) : 0;
  const uniqueCorrect = calcUniqueCorrectWords();
  const numerator = sessionSize ? (pointer >= sessionSize ? sessionSize : pointer + 1) : 0;
  const denominator = sessionSize || Math.min(batchTarget, totalWords);
  const unfamiliarCount = Array.from(unfamiliarIndices).filter(idx => Number.isInteger(idx) && idx >= 0 && idx < totalWords).length;
  const unfamiliarLabel = unfamiliarCount ? ` | 不熟 ${unfamiliarCount} 个` : "";
  const scoreLabel = activeSessionType === "exam" ? "" : " | 积分：不计";
  vocabProgress.textContent = `词库：${wordBankName} | 模式：${modeSummary} | 本次测验：${numerator}/${denominator} | 已答对 ${uniqueCorrect} 个${unfamiliarLabel}${scoreLabel}`;

  if(nextWordBtn) nextWordBtn.disabled = sessionSize === 0;

  const hasPendingSession = Boolean(
    wordSessionState &&
    Array.isArray(wordSessionState.indices) &&
    wordSessionState.indices.length
  );

  if(wordSessionNeedsStart){
    wordDisplay.textContent = hasPendingSession
      ? "继续练习请点击“开始练习”"
      : "请点击“开始练习”抽取题目";
    wordPrompt.textContent = hasPendingSession
      ? "系统已为你保留上次的题目组合"
      : "系统将优先抽取未测验或做错过的单词";
    if(submitWordBtn) submitWordBtn.disabled = true;
    if(nextWordBtn) nextWordBtn.disabled = true;
    return;
  }

  if(!wordSessionState || sessionSize === 0){
    wordDisplay.textContent = "请点击“开始练习”抽取题目";
    wordPrompt.textContent = "系统将优先抽取未测验或做错过的单词";
    if(submitWordBtn) submitWordBtn.disabled = true;
    return;
  }

  if(pointer >= sessionSize){
    wordDisplay.textContent = "本次测验已完成";
    wordPrompt.textContent = "可点击“开始练习”或“下一题”重新开始。";
    if(submitWordBtn) submitWordBtn.disabled = true;
    return;
  }

  const currentIndex = wordSessionState.indices[pointer];
  currentVocabIndex = currentIndex;
  const currentItem = activeVocabulary[currentIndex];
  const baseWordText = currentItem.word || "（未命名单词）";
  wordDisplay.textContent = unfamiliarIndices.has(currentIndex) ? `${baseWordText}（标记不熟）` : baseWordText;
  wordPrompt.textContent = activeSessionType === "exam"
    ? "请选择正确释义"
    : "请选择正确释义（练习模式不计积分）";
  currentWordOptions = buildWordOptions(currentIndex);

  currentWordOptions.forEach((option, idx) => {
    const div = document.createElement("div");
    div.className = "word-option";
    div.textContent = option.text;
    div.addEventListener("click", () => handleWordOptionSelection(idx, div));
    wordOptionsContainer.appendChild(div);
  });

  startWordTimer();
  if(submitWordBtn) submitWordBtn.disabled = true;
}

function advanceWordPointer(options = {}){
  const auto = Boolean(options.auto);
  if(!currentStudent || !activeWordBank) return;

  if(auto){
    wordAutoAdvanceTimer = null;
  }else if(wordAutoAdvanceTimer){
    clearTimeout(wordAutoAdvanceTimer);
    wordAutoAdvanceTimer = null;
  }

  const previousFeedback = auto && wordFeedback ? wordFeedback.textContent : "";

  if(!wordSessionState){
    if(!auto){
      const requested = Number(wordBatchSelect && wordBatchSelect.value) || DEFAULT_WORD_BATCH;
      startNewWordSession(requested);
    }
    return;
  }

  const size = Array.isArray(wordSessionState.indices) ? wordSessionState.indices.length : 0;
  if(size === 0){
    if(!auto){
      const fallback = wordSessionState.batchSize || (Number(wordBatchSelect && wordBatchSelect.value) || DEFAULT_WORD_BATCH);
      startNewWordSession(fallback);
    }
    return;
  }

  if(wordSessionState.pointer >= size){
    if(auto){
      renderWordQuestion();
      if(previousFeedback){
        wordFeedback.textContent = previousFeedback;
      }
    }else{
      const fallback = wordSessionState.batchSize || (Number(wordBatchSelect && wordBatchSelect.value) || DEFAULT_WORD_BATCH);
      startNewWordSession(fallback);
    }
    return;
  }

  if(wordSessionState.pointer < size - 1){
    wordSessionState.pointer++;
  }else{
    wordSessionState.pointer = size;
  }
  saveWordSessionState();
  renderWordQuestion();
  if(auto && wordSessionState && wordSessionState.pointer >= size && previousFeedback){
    wordFeedback.textContent = previousFeedback;
  }
}

function handleWordOptionSelection(index, optionDiv){
  if(wordQuestionGraded) return;
  const optionDivs = wordOptionsContainer.querySelectorAll(".word-option");
  optionDivs.forEach(div => div.classList.remove("selected"));
  optionDiv.classList.add("selected");
  gradeWordAnswer(index);
}

if(submitWordBtn){
  submitWordBtn.addEventListener("click", () => {
    if(selectedWordOptionIndex === null) return;
    gradeWordAnswer(selectedWordOptionIndex);
  });
}

if(nextWordBtn){
  nextWordBtn.addEventListener("click", () => {
    advanceWordPointer({auto: false});
  });
}

function gradeWordAnswer(index, options = {}){
  if(wordQuestionGraded) return;
  if(!currentStudent || !activeWordBank) return;
  if(!wordSessionState || !wordSessionState.indices.length) return;
  if(wordSessionState.pointer >= wordSessionState.indices.length) return;
  stopWordTimer();
  const autoTimeout = Boolean(options && options.autoTimeout);
  const suppressAutoAdvance = Boolean(options && options.suppressAutoAdvance);
  const numericIndex = typeof index === "number" && index >= 0 ? index : -1;
  selectedWordOptionIndex = numericIndex >= 0 ? numericIndex : null;
  const optionDivs = document.querySelectorAll(".word-option");
  const currentIndex = wordSessionState.indices[wordSessionState.pointer];
  const currentItem = activeVocabulary[currentIndex];
  const selectedOption = numericIndex >= 0 ? currentWordOptions[numericIndex] : null;
  const correctOption = currentWordOptions.find(opt => opt.isCorrect);
  optionDivs.forEach((div, idx) => {
    div.classList.remove("selected");
    if(currentWordOptions[idx].isCorrect) div.classList.add("correct");
    if(numericIndex === idx && !currentWordOptions[idx].isCorrect) div.classList.add("wrong");
  });
  const isCorrect = Boolean(selectedOption && selectedOption.isCorrect);
  if(autoTimeout){
    wordFeedback.textContent = `超时，正确释义：${correctOption ? correctOption.text : getMeaningText(currentItem)}`;
  }else{
    wordFeedback.textContent = isCorrect
      ? "答对了！"
      : `答错了，正确释义：${correctOption ? correctOption.text : getMeaningText(currentItem)}`;
  }
  if(currentItem.example){
    exampleDisplay.textContent = `例句：${currentItem.example}`;
  }
  wordHistory.push({index: currentIndex, correct: isCorrect});
  const historyKey = storageKey("wordHistory");
  if(historyKey) localStorage.setItem(historyKey, JSON.stringify(wordHistory));
  if(wordSessionState){
    if(!Array.isArray(wordSessionState.answers)) wordSessionState.answers = [];
    const existingIndex = wordSessionState.answers.findIndex(entry => entry && entry.index === currentIndex);
    const answerEntry = {index: currentIndex, correct: isCorrect};
    if(existingIndex >= 0){
      wordSessionState.answers[existingIndex] = answerEntry;
    }else{
      wordSessionState.answers.push(answerEntry);
    }
  }
  if(isCorrect){
    if(unfamiliarIndices.delete(currentIndex)){
      saveUnfamiliarSet();
    }
  }else{
    if(!unfamiliarIndices.has(currentIndex)){
      unfamiliarIndices.add(currentIndex);
    }
    saveUnfamiliarSet();
  }
  saveWordSessionState();
  if(submitWordBtn) submitWordBtn.disabled = true;
  wordQuestionGraded = true;
  evaluateWordSessionCompletion();
  renderOverallStats();
  if(wordAutoAdvanceTimer){
    clearTimeout(wordAutoAdvanceTimer);
    wordAutoAdvanceTimer = null;
  }
  if(!suppressAutoAdvance){
    const delay = isCorrect ? 400 : 3000;
    wordAutoAdvanceTimer = setTimeout(() => advanceWordPointer({auto: true}), delay);
  }
  return {
    isCorrect,
    correctText: correctOption ? correctOption.text : getMeaningText(currentItem),
    item: currentItem
  };
}

function startNewGrammarSession(requestedSize){
  stopGrammarTimer();
  if(grammarAutoAdvanceTimer){
    clearTimeout(grammarAutoAdvanceTimer);
    grammarAutoAdvanceTimer = null;
  }
  if(!activeGrammarSet){
    grammarSessionState = null;
    grammarHistory = [];
    grammarSessionNeedsStart = true;
    renderGrammarQuestion();
    return;
  }
  const totalQuestions = Array.isArray(activeGrammarSet.questions) ? activeGrammarSet.questions.length : 0;
  if(totalQuestions === 0){
    grammarSessionState = null;
    grammarHistory = [];
    grammarSessionNeedsStart = true;
    renderGrammarQuestion();
    return;
  }
  const normalizedSize = Number.isFinite(requestedSize) && requestedSize > 0
    ? Math.min(Math.floor(requestedSize), totalQuestions)
    : Math.min(20, totalQuestions);
  const indices = shuffleArray(Array.from({length: totalQuestions}, (_, idx) => idx));
  grammarSessionState = {
    indices: indices.slice(0, normalizedSize),
    pointer: 0,
    batchSize: normalizedSize,
    answers: []
  };
  grammarCurrentOptions = [];
  grammarSelectedOptionKey = null;
  grammarQuestionGraded = false;
  grammarSessionNeedsStart = false;
  if(grammarBatchSelect){
    const valueToSet = normalizedSize === totalQuestions && Array.from(grammarBatchSelect.options).some(opt => opt.value === "all")
      ? "all"
      : (Array.from(grammarBatchSelect.options).some(opt => opt.value === String(normalizedSize))
          ? String(normalizedSize)
          : grammarBatchSelect.value);
    grammarBatchSelect.value = valueToSet;
  }
  renderGrammarQuestion();
  renderOverallStats();
}

function renderGrammarQuestion(){
  if(!grammarQuestionDisplay || !grammarOptionsContainer) return;
  grammarOptionsContainer.innerHTML = "";
  if(grammarFeedback) grammarFeedback.textContent = "";
  if(grammarExplanation){
    grammarExplanation.textContent = "";
    grammarExplanation.style.display = "none";
  }
  grammarCurrentOptions = [];
  grammarSelectedOptionKey = null;
  grammarQuestionGraded = false;
  if(submitGrammarBtn) submitGrammarBtn.disabled = true;
  if(nextGrammarBtn) nextGrammarBtn.disabled = true;

  const grammarBankName = activeGrammarSet ? (activeGrammarSet.name || activeGrammarSet.id) : "未选择题库";
  const totalQuestions = activeGrammarSet && Array.isArray(activeGrammarSet.questions) ? activeGrammarSet.questions.length : 0;
  const sessionSize = grammarSessionState ? grammarSessionState.indices.length : 0;
  const pointer = grammarSessionState ? Math.min(Math.max(grammarSessionState.pointer, 0), sessionSize) : 0;
  const numerator = sessionSize ? (pointer >= sessionSize ? sessionSize : pointer + 1) : 0;
  const denominator = sessionSize || (grammarSessionState && grammarSessionState.batchSize ? grammarSessionState.batchSize : Math.min(totalQuestions, Number(grammarBatchSelect && grammarBatchSelect.value !== "all" ? Number(grammarBatchSelect.value) : totalQuestions) || totalQuestions));
  const sessionAnswers = grammarSessionState && Array.isArray(grammarSessionState.answers) ? grammarSessionState.answers : [];
  const sessionCorrect = sessionAnswers.filter(entry => entry && entry.correct).length;
  const accuracy = sessionAnswers.length ? formatPercentage(sessionCorrect / sessionAnswers.length) : null;

  if(grammarProgress){
    const detailLabel = sessionAnswers.length ? ` | 本次已答对 ${sessionCorrect} 题${accuracy ? `（${accuracy}）` : ""}` : "";
    grammarProgress.textContent = activeGrammarSet
      ? `题库：${grammarBankName} | 本次测验：${numerator}/${denominator || totalQuestions}${detailLabel}`
      : `题库：${grammarBankName}`;
  }

  if(!currentStudent){
    grammarQuestionDisplay.textContent = "请先选择学生";
    return;
  }

  if(!activeGrammarSet){
    grammarQuestionDisplay.textContent = "请选择语法题库开始练习";
    return;
  }

  if(totalQuestions === 0){
    grammarQuestionDisplay.textContent = "当前题库暂无试题";
    return;
  }

  if(!grammarSessionState || sessionSize === 0){
    grammarQuestionDisplay.textContent = "请点击“开始练习”抽取题目";
    grammarSessionNeedsStart = true;
    return;
  }

  if(grammarSessionState.pointer >= sessionSize){
    grammarQuestionDisplay.textContent = "本次练习已完成";
    grammarSessionNeedsStart = true;
    if(nextGrammarBtn) nextGrammarBtn.disabled = true;
    return;
  }

  if(grammarSessionNeedsStart){
    grammarQuestionDisplay.textContent = "继续练习请点击“开始练习”";
    if(nextGrammarBtn) nextGrammarBtn.disabled = true;
    if(submitGrammarBtn) submitGrammarBtn.disabled = true;
    return;
  }

  const currentIndex = grammarSessionState.indices[pointer];
  const currentItem = activeGrammarSet.questions[currentIndex];
  const questionText = currentItem && currentItem.question ? currentItem.question : "（题干缺失）";
  grammarQuestionDisplay.textContent = questionText;

  const optionEntries = Object.entries(currentItem.options || {})
    .map(([key, text]) => [String(key).toUpperCase(), text])
    .filter(([key, text]) => key && text);
  grammarCurrentOptions = optionEntries.map(([key, text]) => ({key, text, isCorrect: key === currentItem.answer}));

  optionEntries.forEach(([key, text]) => {
    const optionDiv = document.createElement("div");
    optionDiv.className = "grammar-option";
    optionDiv.setAttribute("role", "button");
    optionDiv.setAttribute("tabindex", "0");

    const keySpan = document.createElement("span");
    keySpan.className = "grammar-option-key";
    keySpan.textContent = `${key}.`;

    const textSpan = document.createElement("span");
    textSpan.textContent = text;

    optionDiv.appendChild(keySpan);
    optionDiv.appendChild(textSpan);
    optionDiv.addEventListener("click", () => handleGrammarOptionSelection(key, optionDiv));
    optionDiv.addEventListener("keydown", event => {
      if(event.key === "Enter" || event.key === " "){
        event.preventDefault();
        handleGrammarOptionSelection(key, optionDiv);
      }
    });
    grammarOptionsContainer.appendChild(optionDiv);
  });

  if(!grammarQuestionGraded) startGrammarTimer();
}

function handleGrammarOptionSelection(optionKey, optionDiv){
  if(grammarQuestionGraded) return;
  grammarSelectedOptionKey = optionKey;
  const optionDivs = grammarOptionsContainer.querySelectorAll(".grammar-option");
  optionDivs.forEach(div => div.classList.remove("selected"));
  if(optionDiv) optionDiv.classList.add("selected");
  gradeGrammarAnswer(optionKey);
}

function gradeGrammarAnswer(optionKey, options = {}){
  if(grammarQuestionGraded) return;
  if(!currentStudent || !activeGrammarSet) return;
  if(!grammarSessionState || !Array.isArray(grammarSessionState.indices) || !grammarSessionState.indices.length) return;
  if(grammarSessionState.pointer >= grammarSessionState.indices.length) return;
  stopGrammarTimer();
  const selectedKey = typeof optionKey === "string" ? optionKey.toUpperCase() : null;
  grammarSelectedOptionKey = selectedKey;
  const optionDivs = grammarOptionsContainer.querySelectorAll(".grammar-option");
  const currentIndex = grammarSessionState.indices[grammarSessionState.pointer];
  const currentItem = activeGrammarSet.questions[currentIndex];
  const correctKey = currentItem.answer;
  optionDivs.forEach(div => {
    const keySpan = div.querySelector(".grammar-option-key");
    const keyValue = keySpan ? keySpan.textContent.replace(/\.$/, "") : "";
    if(keyValue === correctKey){
      div.classList.add("correct");
    }
    if(selectedKey && keyValue === selectedKey && keyValue !== correctKey){
      div.classList.add("wrong");
    }
  });
  const isCorrect = selectedKey === correctKey;
  const autoTimeout = Boolean(options && options.autoTimeout);
  if(autoTimeout){
    grammarFeedback.textContent = `超时，正确答案：${correctKey}. ${currentItem.options[correctKey] || ""}`;
  }else{
    grammarFeedback.textContent = isCorrect
      ? "答对了！"
      : `答错了，正确答案：${correctKey}. ${currentItem.options[correctKey] || ""}`;
  }
  if(grammarExplanation){
    if(currentItem.explanation){
      grammarExplanation.textContent = `解析：${currentItem.explanation}`;
      grammarExplanation.style.display = "block";
    }else{
      grammarExplanation.textContent = "";
      grammarExplanation.style.display = "none";
    }
  }
  grammarHistory.push({index: currentIndex, correct: isCorrect});
  if(grammarSessionState){
    if(!Array.isArray(grammarSessionState.answers)) grammarSessionState.answers = [];
    const existingIndex = grammarSessionState.answers.findIndex(entry => entry && entry.index === currentIndex);
    const answerEntry = {index: currentIndex, correct: isCorrect};
    if(existingIndex >= 0){
      grammarSessionState.answers[existingIndex] = answerEntry;
    }else{
      grammarSessionState.answers.push(answerEntry);
    }
  }
  const historyKey = grammarStorageKey("grammarHistory");
  if(historyKey) localStorage.setItem(historyKey, JSON.stringify(grammarHistory));
  grammarQuestionGraded = true;
  if(submitGrammarBtn) submitGrammarBtn.disabled = true;
  if(nextGrammarBtn) nextGrammarBtn.disabled = false;
  renderOverallStats();
  if(grammarAutoAdvanceTimer){
    clearTimeout(grammarAutoAdvanceTimer);
    grammarAutoAdvanceTimer = null;
  }
}

function advanceGrammarPointer(options = {}){
  const auto = Boolean(options.auto);
  stopGrammarTimer();
  if(!grammarQuestionGraded && !auto) return;
  if(auto){
    grammarAutoAdvanceTimer = null;
  }else if(grammarAutoAdvanceTimer){
    clearTimeout(grammarAutoAdvanceTimer);
    grammarAutoAdvanceTimer = null;
  }
  if(!grammarSessionState || !Array.isArray(grammarSessionState.indices) || !grammarSessionState.indices.length){
    grammarSessionNeedsStart = true;
    renderGrammarQuestion();
    return;
  }
  if(grammarSessionState.pointer >= grammarSessionState.indices.length){
    grammarSessionNeedsStart = true;
    renderGrammarQuestion();
    return;
  }
  if(grammarSessionState.pointer < grammarSessionState.indices.length - 1){
    grammarSessionState.pointer++;
  }else{
    grammarSessionState.pointer = grammarSessionState.indices.length;
    grammarSessionNeedsStart = true;
  }
  grammarQuestionGraded = false;
  grammarSelectedOptionKey = null;
  renderGrammarQuestion();
}

function renderSentenceQuestion(){
  stopSentenceTimer();
  sentenceOptionsContainer.innerHTML = "";
  sentenceAnswerContainer.innerHTML = "";
  sentenceFeedback.textContent = "";
  sentenceHint.textContent = "";
  sentenceLocked = false;
  submitSentenceBtn.disabled = true;
  resetSentenceBtn.disabled = true;
  nextSentenceBtn.disabled = true;

  const sentenceSetName = activeSentenceSet ? activeSentenceSet.name : "未选择句库";

  if(!currentStudent){
    sentenceProgress.textContent = `句库：${sentenceSetName}`;
    sentenceInstruction.textContent = "请先选择学生";
    return;
  }

  if(!activeSentenceSet){
    sentenceProgress.textContent = "句库：未选择";
    sentenceInstruction.textContent = "请选择句库开始句子重组";
    return;
  }

  const totalSentences = activeSentenceSet.items.length;
  if(totalSentences === 0){
    sentenceProgress.textContent = `句库：${sentenceSetName}`;
    sentenceInstruction.textContent = "当前句库暂无内容";
    return;
  }

  if(!sentenceSessionState || !sentenceSessionState.indices.length){
    startNewSentenceSession();
  }

  const sessionSize = sentenceSessionState ? sentenceSessionState.indices.length : 0;
  const pointer = sentenceSessionState ? Math.min(Math.max(sentenceSessionState.pointer, 0), sessionSize) : 0;
  const currentOrdinal = sessionSize ? Math.min(pointer + 1, sessionSize) : 0;
  sentenceProgress.textContent = `句库：${sentenceSetName} | 本轮：${currentOrdinal}/${sessionSize || 1}`;
  nextSentenceBtn.disabled = sessionSize === 0;

  if(!sentenceSessionState || sessionSize === 0){
    sentenceInstruction.textContent = "当前无可用句子，点击“下一句”重新抽题";
    return;
  }

  if(pointer >= sessionSize){
    sentenceInstruction.textContent = "本轮所有句子已完成";
    sentenceHint.textContent = "点击“下一句”重新随机抽取顺序。";
    return;
  }

  const currentIndex = sentenceSessionState.indices[pointer];
  currentSentenceIndex = currentIndex;
  sentenceProgress.textContent += ` | 原句编号：第 ${currentIndex + 1} 句`;
  const item = activeSentenceSet.items[currentIndex];
  sentenceInstruction.textContent = `第 ${currentIndex + 1} 句：请根据提示将英文片段按顺序重组`;
  sentenceHint.textContent = item.chinese ? `中文提示：${item.chinese}` : "中文提示：暂无";

  sentenceOriginalTokens = tokenizeSentence(item.english);
  const tokenObjects = sentenceOriginalTokens.map((text, index) => ({text, index}));
  sentenceAvailableTokens = shuffleArray(tokenObjects);
  if(isTokensInOriginalOrder(sentenceAvailableTokens)){
    sentenceAvailableTokens = shuffleArray(tokenObjects);
  }
  sentenceSelectedTokens = [];
  submitSentenceBtn.disabled = false;
  resetSentenceBtn.disabled = false;
  rebuildSentenceContainers();
  startSentenceTimer();
}
function rebuildSentenceContainers(){
  sentenceOptionsContainer.innerHTML = "";
  sentenceAvailableTokens.forEach((token, idx) => {
    const div = document.createElement("div");
    div.className = "sentence-token";
    div.textContent = token.text;
    if(sentenceLocked){
      div.classList.add("disabled");
    }else{
      div.addEventListener("click", () => {
        sentenceSelectedTokens.push(token);
        sentenceAvailableTokens.splice(idx,1);
        rebuildSentenceContainers();
      });
    }
    sentenceOptionsContainer.appendChild(div);
  });

  sentenceAnswerContainer.innerHTML = "";
  sentenceSelectedTokens.forEach((token, idx) => {
    const div = document.createElement("div");
    div.className = "sentence-token";
    if(sentenceLocked){
      div.classList.add(token.correctPlacement ? "correct" : "wrong");
    }
    div.textContent = token.text;
    if(!sentenceLocked){
      div.addEventListener("click", () => {
        sentenceAvailableTokens.push(token);
        sentenceSelectedTokens.splice(idx,1);
        rebuildSentenceContainers();
      });
    }
    sentenceAnswerContainer.appendChild(div);
  });
}

resetSentenceBtn.addEventListener("click", () => {
  if(sentenceLocked || !currentStudent || !activeSentenceSet) return;
  stopSentenceTimer();
  renderSentenceQuestion();
});

submitSentenceBtn.addEventListener("click", () => {
  if(sentenceLocked || !currentStudent || !activeSentenceSet) return;
  stopSentenceTimer();
  if(!sentenceSessionState || !sentenceSessionState.indices.length) return;
  if(sentenceSessionState.pointer >= sentenceSessionState.indices.length) return;
  if(sentenceSelectedTokens.length !== sentenceOriginalTokens.length){
    alert("请先选完全部片段");
    return;
  }
  const currentIndex = sentenceSessionState.indices[sentenceSessionState.pointer];
  const isCorrect = sentenceSelectedTokens.every((token, idx) => token.index === idx);
  sentenceSelectedTokens = sentenceSelectedTokens.map((token, idx) => ({
    ...token,
    correctPlacement: token.index === idx
  }));
  sentenceLocked = true;
  submitSentenceBtn.disabled = true;
  resetSentenceBtn.disabled = true;
  rebuildSentenceContainers();

  const originalSentence = sentenceOriginalTokens.join(" ").replace(/\s([.,!?;:])/g, "$1");
  sentenceFeedback.textContent = isCorrect
    ? "答对了！"
    : `答错了，正确顺序：${originalSentence}`;

  sentenceHistory.push({index: currentIndex, correct: isCorrect});
  const historyKey = sentenceStorageKey("sentenceHistory");
  if(historyKey) localStorage.setItem(historyKey, JSON.stringify(sentenceHistory));
  saveSentenceSessionState();
  renderOverallStats();
});

nextSentenceBtn.addEventListener("click", () => {
  if(!currentStudent || !activeSentenceSet) return;
  stopSentenceTimer();
  if(!sentenceSessionState || !sentenceSessionState.indices.length){
    startNewSentenceSession();
  }else{
    const size = sentenceSessionState.indices.length;
    if(size === 0){
      startNewSentenceSession();
    }else if(sentenceSessionState.pointer >= size){
      startNewSentenceSession();
    }else if(sentenceSessionState.pointer < size - 1){
      sentenceSessionState.pointer++;
    }else{
      sentenceSessionState.pointer = size;
    }
  }
  saveSentenceSessionState();
  renderSentenceQuestion();
});

resetBtn.addEventListener("click", () => {
  if(!currentStudent) return;
  if(confirm(`确定要清除 ${currentStudent} 的所有进度吗？`)){
    stopWordTimer();
    stopGrammarTimer();
    stopSentenceTimer();
    wordBanks.forEach(bank => {
      const base = `${currentStudent}-${bank.id}-`;
      ["wordIndex","wordHistory","wordSession","unfamiliar"].forEach(type => {
        localStorage.removeItem(`${base}${type}`);
      });
    });
    sentenceSets.forEach(set => {
      const base = `${currentStudent}-sentence-${set.id}-`;
      ["sentenceHistory","sentenceSession"].forEach(type => {
        localStorage.removeItem(`${base}${type}`);
      });
    });
    grammarBanks.forEach(bank => {
      const base = `${currentStudent}-grammar-${bank.id}-`;
      ["grammarHistory"].forEach(type => {
        localStorage.removeItem(`${base}${type}`);
      });
    });
    currentVocabIndex = 0;
    wordHistory = [];
    wordSessionState = null;
    saveWordSessionState();
    currentSentenceIndex = 0;
    sentenceHistory = [];
    sentenceAvailableTokens = [];
    sentenceSelectedTokens = [];
    sentenceOriginalTokens = [];
    sentenceLocked = false;
    wordFeedback.textContent = "";
    exampleDisplay.textContent = "";
    sentenceFeedback.textContent = "";
    if(grammarAutoAdvanceTimer){
      clearTimeout(grammarAutoAdvanceTimer);
      grammarAutoAdvanceTimer = null;
    }
    grammarSessionState = null;
    grammarHistory = [];
    grammarCurrentOptions = [];
    grammarSelectedOptionKey = null;
    grammarQuestionGraded = false;
    grammarSessionNeedsStart = true;
    if(grammarFeedback) grammarFeedback.textContent = "";
    if(grammarExplanation){
      grammarExplanation.textContent = "";
      grammarExplanation.style.display = "none";
    }
    if(wordBatchSelect) wordBatchSelect.value = String(DEFAULT_WORD_BATCH);
    if(currentStudent && wordScoreboard && wordScoreboard[currentStudent]){
      delete wordScoreboard[currentStudent];
      saveWordScoreboard();
    }
    renderWordQuestion();
    renderGrammarQuestion();
    renderSentenceQuestion();
    updateGrammarControlsState();
    renderOverallStats();
  }
});

function calcWordAccuracy(){
  if(!wordHistory.length) return 0;
  const correctCount = wordHistory.filter(entry => entry.correct).length;
  return correctCount / wordHistory.length;
}

function calcUniqueCorrectWords(){
  if(!wordHistory.length) return 0;
  const set = new Set();
  wordHistory.forEach(entry => {
    if(entry.correct) set.add(entry.index);
  });
  return set.size;
}

function calcSentenceAccuracy(){
  if(!sentenceHistory.length) return 0;
  const correctCount = sentenceHistory.filter(entry => entry.correct).length;
  return correctCount / sentenceHistory.length;
}

function calcSentenceUniqueCorrect(){
  if(!sentenceHistory.length) return 0;
  const set = new Set();
  sentenceHistory.forEach(entry => {
    if(entry.correct) set.add(entry.index);
  });
  return set.size;
}

function calcGrammarAccuracy(){
  if(!grammarHistory.length) return 0;
  const correctCount = grammarHistory.filter(entry => entry.correct).length;
  return correctCount / grammarHistory.length;
}

function calcGrammarCorrectCount(){
  if(!grammarHistory.length) return 0;
  return grammarHistory.filter(entry => entry.correct).length;
}

function renderOverallStats(){
  if(!overallStats) return;

  if(!currentStudent){
    overallStats.innerHTML = `
      <div class="stat">
        <div style="font-size:32px;font-weight:700;">-</div>
        <div>请选择学生查看统计</div>
      </div>`;
    return;
  }

  if(!activeWordBank && wordBankSelect && Array.isArray(subWordBankMap[wordBankSelect.value]) && subWordBankMap[wordBankSelect.value].length){
    const parentName = topLevelWordBanks.find(bank => bank.id === wordBankSelect.value);
    const parentLabel = parentName ? parentName.name : "子词库";
    overallStats.innerHTML = `
      <div class="stat">
        <div style="font-size:32px;font-weight:700;">${parentLabel}</div>
        <div>请选择子词库开始练习</div>
      </div>`;
    return;
  }

  const scoreData = getWordScoreData(currentStudent);
  const rewardScore = Number.isFinite(scoreData.reward) ? scoreData.reward : 0;
  const penaltyScore = Number.isFinite(scoreData.penalty) ? scoreData.penalty : 0;
  const totalScore = Number.isFinite(scoreData.total) ? scoreData.total : rewardScore + penaltyScore;
  const latestRecord = Array.isArray(scoreData.history) && scoreData.history.length ? scoreData.history[0] : null;
  const rewardCard = `
    <div class="stat">
      <div style="font-size:32px;font-weight:700;">${formatScoreDelta(rewardScore)}</div>
      <div>奖励积分</div>
    </div>`;
  const penaltyCard = `
    <div class="stat">
      <div style="font-size:32px;font-weight:700;">${formatScoreDelta(penaltyScore)}</div>
      <div>惩扣积分</div>
    </div>`;
  const redeemCard = `
    <div class="stat">
      <div style="font-size:32px;font-weight:700;">${Math.round(Math.max(0, scoreData.redeemable || 0))}</div>
      <div>可兑换积分</div>
    </div>`;
  const totalCard = `
    <div class="stat">
      <div style="font-size:32px;font-weight:700;">${totalScore}</div>
      <div>当前积分</div>
    </div>`;
  const latestCard = latestRecord
    ? `
      <div class="stat">
        <div style="font-size:32px;font-weight:700;">${formatScoreDelta(latestRecord.delta)}</div>
        <div>${formatWordScoreHistoryLabel(latestRecord)}</div>
      </div>`
    : `
      <div class="stat">
        <div style="font-size:32px;font-weight:700;">-</div>
        <div>暂无积分记录</div>
      </div>`;

  const cards = [rewardCard, penaltyCard, redeemCard, totalCard];

  if(activeWordBank){
    const totalWords = activeVocabulary.length;
    const wordAttempts = wordHistory.length;
    const wordAccuracy = Math.round(calcWordAccuracy() * 100);
    const wordUnique = calcUniqueCorrectWords();
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${wordAttempts}</div>
          <div>累计单词答题</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${wordAccuracy}%</div>
          <div>单词正确率</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${wordUnique}/${totalWords || 0}</div>
          <div>已答对单词</div>
        </div>`
    );
  }else if(activeGrammarSet){
    const totalGrammar = Array.isArray(activeGrammarSet.questions) ? activeGrammarSet.questions.length : 0;
    const grammarAttempts = grammarHistory.length;
    const grammarAccuracy = Math.round(calcGrammarAccuracy() * 100);
    const grammarCorrect = calcGrammarCorrectCount();
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${grammarAttempts}</div>
          <div>累计语法答题</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${grammarAccuracy}%</div>
          <div>语法正确率</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${grammarCorrect}/${totalGrammar || 0}</div>
          <div>已答对题目</div>
        </div>`
    );
  }else if(activeSentenceSet){
    const totalSentences = activeSentenceSet.items.length;
    const sentenceAttempts = sentenceHistory.length;
    const sentenceAccuracy = Math.round(calcSentenceAccuracy() * 100);
    const sentenceUnique = calcSentenceUniqueCorrect();
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${sentenceAttempts}</div>
          <div>累计句子练习</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${sentenceAccuracy}%</div>
          <div>句子正确率</div>
        </div>`
    );
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">${sentenceUnique}/${totalSentences || 0}</div>
          <div>已正确句子</div>
        </div>`
    );
  }else{
    cards.push(
      `
        <div class="stat">
          <div style="font-size:32px;font-weight:700;">-</div>
          <div>请选择词库、语法或句库开始测验</div>
        </div>`
    );
  }

  cards.push(latestCard);
  overallStats.innerHTML = cards.join("\n");
}

function normalize3500Entries(entries){
  if(!Array.isArray(entries)) return [];
  return entries
    .map(entry => normalize3500Entry(entry))
    .filter(Boolean);
}

function normalize3500Entry(entry){
  if(!entry || !entry.word) return null;
  const segments = [];
  const posCollector = new Set();
  if(entry.meaning){
    collectDefinitionSegment(segments, entry.type || entry.partOfSpeech, entry.meaning, posCollector);
  }

  let idx = 2;
  while(entry[`type${idx}`] || entry[`meaning${idx}`]){
    collectDefinitionSegment(segments, entry[`type${idx}`], entry[`meaning${idx}`], posCollector);
    idx++;
  }

  if(entry.definition){
    collectDefinitionSegment(segments, entry.partOfSpeech, entry.definition, posCollector);
  }

  if(entry.explanation){
    collectDefinitionSegment(segments, entry.partOfSpeech, entry.explanation, posCollector);
  }

  if(entry.description){
    collectDefinitionSegment(segments, null, entry.description, posCollector);
  }

  if(entry.forms){
    const formText = toNormalizedText(entry.forms);
    if(formText) segments.push(`形式：${formText}`);
  }

  if(entry.alternate){
    const altText = toNormalizedText(entry.alternate);
    if(altText) segments.push(`变体：${altText}`);
  }

  const meaning = segments.filter(Boolean).join("；").replace(/；+/g, "；").replace(/^；|；$/g, "");
  const example = entry.example
    ? toNormalizedText(entry.example)
    : (Array.isArray(entry.examples) ? entry.examples.map(toNormalizedText).filter(Boolean).join("；") : "");

  const fallbackMeaning = toNormalizedText(entry.meaning)
    || toNormalizedText(entry.definition)
    || toNormalizedText(entry.explanation)
    || toNormalizedText(entry.description)
    || "释义待补充";

  return {
    word: String(entry.word).trim(),
    meaning: meaning || fallbackMeaning,
    example: example || "",
    posTags: Array.from(posCollector)
  };
}

function buildTextbookBanks(source){
  const banks = [];
  let counter = 0;
  if(!source || typeof source !== "object") return banks;
  Object.keys(source).forEach(bookId => {
    const books = normalizeTextbookBooks(bookId, source[bookId]);
    books.forEach(book => {
      const units = book && book.units && typeof book.units === "object" ? book.units : {};
      Object.keys(units).forEach(unitName => {
        const unit = units[unitName] || {};
        const normalized = normalizeTextbookEntries(unit["词汇"], unit["词组"]);
        if(!normalized.length) return;
        const bankId = `textbook-${bookId}-${++counter}`;
        banks.push({
          id: bankId,
          name: `${book.name || bookId} · ${unitName}`,
          parentId: "textbook",
          bookId,
          unitName,
          items: normalized,
          count: normalized.length
        });
      });
    });
  });
  return banks;
}

function normalizeTextbookBooks(bookId, payload){
  const books = [];
  if(!payload || typeof payload !== "object") return books;
  if(payload.name && payload.units && typeof payload.units === "object"){
    books.push({id: bookId, name: String(payload.name), units: payload.units});
    return books;
  }
  Object.keys(payload).forEach(name => {
    const units = payload[name];
    if(units && typeof units === "object"){
      books.push({id: bookId, name, units});
    }
  });
  return books;
}

function normalizeTextbookEntries(words, phrases){
  const items = [];
  (Array.isArray(words) ? words : []).forEach(word => {
    const entry = normalizeTextbookEntry(word);
    if(entry) items.push(entry);
  });
  (Array.isArray(phrases) ? phrases : []).forEach(phrase => {
    const entry = normalizeTextbookEntry(phrase, true);
    if(entry) items.push(entry);
  });
  return items;
}

function normalizeTextbookEntry(raw, isPhrase){
  let word = "";
  let meaning = "";
  let example = "";
  if(typeof raw === "string" || typeof raw === "number"){
    word = toNormalizedText(raw);
  }else if(raw && typeof raw === "object"){
    word = toNormalizedText(raw.word || raw.phrase || raw.term || raw.text || raw.key || "");
    meaning = toNormalizedText(raw.meaning || raw.translation || raw.cn || raw.definition || raw.explanation || raw.desc || "");
    example = toNormalizedText(raw.example || raw.sample || raw.sentence || "");
  }
  if(!word) return null;
  if(!meaning){
    meaning = lookupMeaning(word);
  }
  if(!meaning){
    meaning = isPhrase ? "词组" : "释义待补充";
  }
  if(example){
    example = example.replace(/^[^A-Za-z0-9]+/, "").trim();
  }
  const entry = {word, meaning, example: example || ""};
  if(raw && typeof raw === "object"){
    const posCandidates = [raw.pos, raw.type, raw.partOfSpeech, raw.category];
    const posTags = normalizePosTokens(posCandidates);
    if(posTags.length) entry.posTags = dedupeTokens(posTags);
  }
  addMeaningToLookup(word, meaning);
  return entry;
}

function normalizeGrammarQuestions(items){
  if(!Array.isArray(items)) return [];
  return items
    .map((item, index) => {
      if(!item || typeof item !== "object") return null;
      const questionText = toNormalizedText(item.question);
      const optionsRaw = item.options && typeof item.options === "object" ? item.options : {};
      const optionEntries = Object.entries(optionsRaw)
        .map(([key, value]) => [toNormalizedText(key).toUpperCase(), toNormalizedText(value)])
        .filter(([key, value]) => Boolean(key) && Boolean(value));
      const options = {};
      optionEntries
        .sort((a, b) => a[0].localeCompare(b[0], "zh-Hans-CN"))
        .forEach(([key, value]) => {
          if(!options[key]) options[key] = value;
        });
      const answerKey = toNormalizedText(item.answer).toUpperCase();
      const explanationText = toNormalizedText(item.explanation);
      if(!questionText || !answerKey || !options[answerKey]) return null;
      return {
        id: Number.isFinite(item.id) ? item.id : index + 1,
        question: questionText,
        options,
        answer: answerKey,
        explanation: explanationText
      };
    })
    .filter(Boolean);
}

function collectDefinitionSegment(target, pos, definition, posCollector){
  const definitionText = toNormalizedText(definition);
  if(!definitionText) return;
  const posText = Array.isArray(pos)
    ? pos.map(toNormalizedText).filter(Boolean).join(", ")
    : toNormalizedText(pos);
  if(posCollector && posText){
    addPosTokens(posCollector, posText);
  }
  target.push(posText ? `${posText} ${definitionText}`.trim() : definitionText);
}

function addPosTokens(targetSet, raw){
  if(!targetSet) return;
  const tokens = normalizePosTokens(raw);
  tokens.forEach(token => targetSet.add(token));
}

function normalizePosTokens(raw){
  if(!raw && raw !== 0) return [];
  const output = [];
  const stack = Array.isArray(raw) ? raw.slice() : [raw];
  while(stack.length){
    const current = stack.pop();
    if(current === undefined || current === null) continue;
    if(Array.isArray(current)){
      stack.push(...current);
      continue;
    }
    const text = String(current)
      .replace(/[()（）]/g, "")
      .replace(/&/g, ",");
    text.split(/[\\/\s，,；;、]+/).forEach(piece => {
      const trimmed = piece && piece.trim();
      if(!trimmed) return;
      output.push(trimmed.replace(/\.+$/g, "."));
    });
  }
  return output.filter(Boolean);
}

function toNormalizedText(input){
  if(input === undefined || input === null) return "";
  if(Array.isArray(input)){
    return input.map(item => toNormalizedText(item)).filter(Boolean).join(", ");
  }
  const text = String(input).trim();
  return text;
}

const POS_ABBREVIATION_KEYS = new Set([
  "n","v","vt","vi","vtvi","adj","adv","ad","a","prep","conj","pron","num","art","aux","auxv","auxi","det","modal","int","interj","pl","sing","link","abbr"
]);

function getPosTagsForEntry(item, meaningText){
  const collected = [];
  if(item){
    if(Array.isArray(item.posTags) && item.posTags.length){
      collected.push(...item.posTags);
    }else if(item.posTags){
      collected.push(...normalizePosTokens(item.posTags));
    }else if(item.pos){
      collected.push(...normalizePosTokens(item.pos));
    }
  }
  if(meaningText){
    const trailing = meaningText.match(/\(([^()]+)\)\s*$/);
    if(trailing){
      collected.push(...normalizePosTokens(trailing[1]));
    }
    const leading = meaningText.match(/^([A-Za-z\.\s\\/,;&]+)/);
    if(leading){
      collected.push(...normalizePosTokens(leading[1]));
    }
  }
  return dedupeTokens(collected);
}

function extractMeaningTokens(meaning){
  if(!meaning) return [];
  const cleaned = String(meaning)
    .replace(/（[^）]*）/g, " ")
    .replace(/\([^)]*\)/g, " ");
  const roughTokens = cleaned
    .split(/[^A-Za-z0-9\u4e00-\u9fa5]+/)
    .map(token => token.trim())
    .filter(Boolean);
  const filtered = roughTokens.filter(token => !isLikelyPosToken(token));
  return dedupeTokens(filtered);
}

function isLikelyPosToken(token){
  const normalized = normalizeComparisonToken(token).replace(/\.+$/g, "");
  if(!normalized) return false;
  if(POS_ABBREVIATION_KEYS.has(normalized)) return true;
  const lettersOnly = normalized.replace(/[^a-z]/g, "");
  return POS_ABBREVIATION_KEYS.has(lettersOnly);
}

function dedupeTokens(tokens){
  if(!Array.isArray(tokens) || !tokens.length) return [];
  const seen = new Set();
  const result = [];
  tokens.forEach(token => {
    const key = normalizeComparisonToken(token);
    if(!key) return;
    if(seen.has(key)) return;
    seen.add(key);
    result.push(token);
  });
  return result;
}

function countOverlap(listA, listB){
  if(!Array.isArray(listA) || !Array.isArray(listB) || !listA.length || !listB.length) return 0;
  const setB = new Set(listB.map(normalizeComparisonToken));
  let count = 0;
  listA.forEach(item => {
    const key = normalizeComparisonToken(item);
    if(key && setB.has(key)) count++;
  });
  return count;
}

function normalizeComparisonToken(token){
  return String(token || "").trim().toLowerCase().replace(/\.+$/g, "");
}

function getWordLetterLength(word){
  if(!word) return 0;
  return String(word).replace(/[^A-Za-z]/g, "").length;
}

function calculateDistractorScore(targetMeta, candidateMeta){
  if(!isMeaningCandidateViable(candidateMeta.meaning)) return null;

  let score = 0;
  const posOverlap = countOverlap(targetMeta.posTags, candidateMeta.posTags);
  if(targetMeta.posTags.length && candidateMeta.posTags.length){
    if(posOverlap > 0){
      score += 6 + posOverlap * 2;
    }else{
      score -= 2;
    }
  }else if(candidateMeta.posTags.length){
    score += 1;
  }

  const tokenOverlap = countOverlap(targetMeta.tokens, candidateMeta.tokens);
  if(tokenOverlap > 0){
    score += tokenOverlap * 4;
    const unionSize = new Set([...targetMeta.tokens.map(normalizeComparisonToken), ...candidateMeta.tokens.map(normalizeComparisonToken)]).size;
    if(unionSize){
      score += (tokenOverlap / unionSize) * 5;
    }
  }

  const meaningDiff = Math.abs(targetMeta.meaningLength - candidateMeta.meaningLength);
  score += Math.max(0, 4 - meaningDiff / 6);

  if(targetMeta.wordLength && candidateMeta.wordLength){
    const wordDiff = Math.abs(targetMeta.wordLength - candidateMeta.wordLength);
    score += Math.max(0, 2.5 - wordDiff / 2);
  }

  if(!candidateMeta.tokens.length){
    score -= 1.5;
  }else if(tokenOverlap === candidateMeta.tokens.length && candidateMeta.tokens.length === targetMeta.tokens.length){
    score -= 2;
  }

  if(/释义待补充/.test(candidateMeta.meaning)){
    score -= 5;
  }

  score += Math.random();
  return score;
}

function isMeaningCandidateViable(text){
  if(!text) return false;
  const trimmed = String(text).trim();
  if(!trimmed) return false;
  if(trimmed === "释义待补充") return false;
  if(trimmed.length <= 1) return false;
  return true;
}

function buildWordOptions(targetIndex){
  if(!activeWordBank) return [];
  const totalWords = activeVocabulary.length;
  if(totalWords === 0) return [];
  const targetItem = activeVocabulary[targetIndex];
  const correctMeaning = getMeaningText(targetItem);
  const targetPosTags = getPosTagsForEntry(targetItem, correctMeaning);
  const targetTokens = extractMeaningTokens(correctMeaning);
  const targetWordLength = getWordLetterLength(targetItem && targetItem.word);
  const targetMeta = {
    posTags: targetPosTags,
    tokens: targetTokens,
    wordLength: targetWordLength,
    meaningLength: correctMeaning ? correctMeaning.length : 0
  };

  const candidateMap = new Map();
  activeVocabulary.forEach((item, idx) => {
    if(idx === targetIndex) return;
    const meaningText = getMeaningText(item);
    const trimmed = meaningText ? meaningText.trim() : "";
    if(!trimmed || trimmed === correctMeaning) return;
    const candidateMeta = {
      posTags: getPosTagsForEntry(item, trimmed),
      tokens: extractMeaningTokens(trimmed),
      wordLength: getWordLetterLength(item && item.word),
      meaningLength: trimmed.length,
      meaning: trimmed
    };
    const score = calculateDistractorScore(targetMeta, candidateMeta);
    if(score === null) return;
    const existing = candidateMap.get(trimmed);
    if(!existing || existing.score < score){
      candidateMap.set(trimmed, {text: trimmed, score, meta: candidateMeta});
    }
  });

  let candidates = Array.from(candidateMap.values()).sort((a, b) => b.score - a.score);
  const distractors = [];
  const usedMeanings = new Set([correctMeaning]);

  const primaryPool = shuffleArray(candidates.slice(0, 8));
  primaryPool.forEach(candidate => {
    if(distractors.length >= 3) return;
    if(!usedMeanings.has(candidate.text) && isMeaningCandidateViable(candidate.text)){
      distractors.push(candidate.text);
      usedMeanings.add(candidate.text);
    }
  });

  if(distractors.length < 3){
    for(const candidate of candidates){
      if(distractors.length >= 3) break;
      if(!usedMeanings.has(candidate.text) && isMeaningCandidateViable(candidate.text)){
        distractors.push(candidate.text);
        usedMeanings.add(candidate.text);
      }
    }
  }

  if(distractors.length < 3){
    const fallbackMeanings = [];
    activeVocabulary.forEach((item, idx) => {
      if(idx === targetIndex) return;
      const meaningText = getMeaningText(item);
      if(!meaningText || usedMeanings.has(meaningText)) return;
      if(!isMeaningCandidateViable(meaningText)) return;
      fallbackMeanings.push(meaningText);
      usedMeanings.add(meaningText);
    });
    shuffleArray(fallbackMeanings)
      .slice(0, 3 - distractors.length)
      .forEach(text => distractors.push(text));
  }

  const staticFallback = ["提升士气","调整计划","巩固记忆","保持关注","合理安排"];
  while(distractors.length < 3 && staticFallback.length){
    const candidate = staticFallback.shift();
    if(candidate && !usedMeanings.has(candidate) && candidate !== correctMeaning){
      distractors.push(candidate);
      usedMeanings.add(candidate);
    }
  }

  let placeholderIndex = 1;
  while(distractors.length < 3){
    const filler = `近义释义 ${placeholderIndex++}`;
    if(!usedMeanings.has(filler)){
      distractors.push(filler);
      usedMeanings.add(filler);
    }
  }

  const options = distractors.map(text => ({text, isCorrect:false}));
  options.push({text: correctMeaning, isCorrect:true});
  return shuffleArray(options);
}

function getMeaningText(item){
  const raw = item.meaning || item.cn || "";
  const trimmed = typeof raw === "string" ? raw.trim() : "";
  return trimmed || "释义待补充";
}

function formatMeaning(entry){
  const meaning = entry.cn || "";
  const pos = entry.pos ? ` (${entry.pos})` : "";
  const combined = `${meaning}${pos}`.trim();
  return combined || "释义待补充";
}

function tokenizeSentence(sentence){
  if(!sentence) return [];
  const tokens = sentence.match(/[A-Za-z]+(?:'[A-Za-z]+)?|\d+|[^\s]/g);
  return tokens || [];
}

function isTokensInOriginalOrder(tokens){
  for(let i=0;i<tokens.length;i++){
    if(tokens[i].index !== i) return false;
  }
  return true;
}

function shuffleArray(source){
  const array = source.slice();
  for(let i = array.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

renderWordQuestion();
renderGrammarQuestion();
renderSentenceQuestion();
renderOverallStats();
updateSectionVisibility();
</script>
</body>
</html>
