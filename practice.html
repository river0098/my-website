<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>è‹±è¯­æåˆ†ç³»ç»Ÿ Â· ç»ƒä¹ æ¨¡å¼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft YaHei", Arial, sans-serif;
      background: radial-gradient(circle at 15% 20%, rgba(132, 159, 255, 0.35), transparent 45%),
                  radial-gradient(circle at 85% 15%, rgba(169, 132, 255, 0.35), transparent 40%),
                  linear-gradient(140deg, #f8f9ff, #eef2ff 50%, #f7f9ff 100%);
      color: #2d3561;
    }
    .practice-shell {
      max-width: 1120px;
      margin: 32px auto;
      padding: 0 24px 48px;
    }
    .practice-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(157, 174, 255, 0.35);
      border-radius: 24px;
      padding: 22px 30px;
      box-shadow: 0 20px 45px rgba(70, 78, 156, 0.16);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 18px;
      z-index: 10;
    }
    .practice-logo {
      font-size: 22px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 12px;
      color: #27305c;
    }
    .practice-logo span {
      font-size: 26px;
    }
    .practice-header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .type-switch {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(235, 240, 255, 0.9);
      border-radius: 18px;
      padding: 6px;
    }
    .type-btn {
      border: none;
      background: transparent;
      padding: 8px 18px;
      border-radius: 14px;
      font-size: 14px;
      color: #46508d;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .type-btn:hover {
      background: rgba(118, 134, 233, 0.18);
    }
    .type-btn.active {
      background: linear-gradient(135deg, #6f7dff, #9d5bff);
      color: #fff;
      box-shadow: 0 8px 20px rgba(111, 125, 255, 0.4);
    }
    .btn-ghost {
      border: 1px solid rgba(111, 125, 255, 0.35);
      background: rgba(255, 255, 255, 0.85);
      color: #505a92;
      padding: 9px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .btn-ghost:hover {
      background: rgba(111, 125, 255, 0.12);
    }
    .student-badge {
      margin: 26px 0 18px;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      border-radius: 14px;
      background: rgba(235, 240, 255, 0.65);
      color: #394173;
      border: 1px solid rgba(157, 174, 255, 0.35);
    }
    .student-badge span {
      font-weight: 600;
    }
    .practice-stats {
      font-size: 15px;
      color: #3c4672;
      background: linear-gradient(135deg, rgba(243,246,255,0.8) 0%, #ffffff 70%);
      border: 1px solid #d7ddff;
      border-radius: 18px;
      padding: 14px 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      box-shadow: 0 10px 26px rgba(90, 108, 179, 0.12);
      min-height: 54px;
    }
    .practice-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: center;
      background: linear-gradient(135deg, #f9faff 0%, #eef1ff 100%);
      border: 1px solid #e2e7ff;
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 20px rgba(70, 92, 182, 0.08);
      margin-top: 18px;
    }
    .toolbar-section {
      display: flex;
      flex: 1 1 auto;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .toolbar-section label {
      font-size: 15px;
      color: #3c4672;
      font-weight: 600;
    }
    .toolbar-section select,
    .toolbar-section input {
      padding: 10px 14px;
      border: 1px solid #cfd5ef;
      background: #fff;
      min-width: 220px;
      border-radius: 12px;
      font-size: 14px;
      color: #3a4377;
    }
    .toolbar-section input[type="search"] {
      flex: 1 1 240px;
    }
    .toolbar-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .btn-secondary,
    .btn-accent {
      border: none;
      border-radius: 12px;
      padding: 10px 18px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .btn-secondary {
      background: #f1f3f9;
      color: #4b5675;
      border: 1px solid rgba(161, 174, 220, 0.35);
    }
    .btn-secondary:hover { background: #e4e8f5; }
    .btn-accent {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      box-shadow: 0 10px 24px rgba(102, 126, 234, 0.32);
    }
    .btn-accent:hover { transform: translateY(-1px); }
    .practice-content {
      margin-top: 20px;
      background: #ffffff;
      border: 1px solid #dde2ff;
      border-radius: 18px;
      padding: 26px 30px;
      box-shadow: 0 16px 32px rgba(50, 64, 145, 0.12);
      min-height: 360px;
    }
    .practice-content::-webkit-scrollbar { width: 8px; }
    .practice-content::-webkit-scrollbar-thumb {
      background: rgba(120, 134, 218, 0.45);
      border-radius: 4px;
    }
    .practice-content::-webkit-scrollbar-track { background: rgba(228, 233, 255, 0.6); }
    .loading-state,
    .practice-empty {
      text-align: center;
      color: #5b6697;
      font-size: 16px;
      padding: 80px 20px;
    }
    .loading-state span {
      display: inline-block;
      margin-top: 18px;
      padding: 8px 18px;
      background: rgba(118, 134, 233, 0.12);
      border-radius: 18px;
      color: #4c57a4;
      font-size: 14px;
    }
    .quiz-card {
      background: #ffffff;
      border: 1px solid #dce1ff;
      border-radius: 20px;
      padding: 26px 28px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 18px 36px rgba(44, 58, 146, 0.12);
    }
    .quiz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 15px;
      color: #495486;
      font-weight: 600;
    }
    .quiz-prompt {
      font-size: 24px;
      font-weight: 600;
      color: #2c3e50;
    }
    .practice-entry-meta {
      font-size: 14px;
      color: #56608c;
      background: rgba(234, 238, 255, 0.6);
      padding: 10px 14px;
      border-radius: 12px;
    }
    .quiz-options {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(1, minmax(0, 1fr));
    }
    @media (min-width: 720px) {
      .quiz-options {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    .quiz-option {
      padding: 12px 16px;
      border: 1px solid #dfe3ee;
      border-radius: 12px;
      background: #fff;
      cursor: pointer;
      text-align: left;
      font-size: 14px;
      color: #3a4460;
      transition: all 0.2s ease;
      box-shadow: 0 8px 18px rgba(120, 134, 218, 0.09);
    }
    .quiz-option:hover {
      border-color: #667eea;
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.25);
      transform: translateY(-1px);
    }
    .quiz-option.correct {
      border-color: #34c38f;
      background: #e6f5ef;
      color: #217a55;
      box-shadow: 0 10px 24px rgba(52, 195, 143, 0.25);
    }
    .quiz-option.incorrect {
      border-color: #ff6c6c;
      background: #fff1f1;
      color: #c0392b;
    }
    .quiz-answer {
      padding: 16px;
      border-radius: 12px;
      background: #fff;
      border: 1px solid #e3e7f2;
      font-size: 14px;
      color: #4b5675;
      line-height: 1.6;
      box-shadow: inset 0 0 0 1px rgba(120, 134, 218, 0.1);
    }
    .quiz-answer.hidden { display: none; }
    .quiz-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
    }
    .quiz-hint { font-size: 13px; color: #6c757d; }
    .sentence-assembly,
    .sentence-pool {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      padding: 16px;
      border-radius: 16px;
      border: 1px dashed #cbd5ff;
      background: linear-gradient(135deg, rgba(245,248,255,0.9), #ffffff);
      min-height: 78px;
      width: 100%;
      box-sizing: border-box;
      justify-content: flex-start;
    }
    .sentence-assembly { flex-wrap: wrap; }
    .sentence-pool { flex-wrap: wrap; overflow: visible; max-height: none; padding-bottom: 0; }
    .sentence-assembly { border-style: solid; background: #ffffff; }
    .sentence-assembly.is-empty { border-style: dashed; color: #9aa3bb; }
    .sentence-assembly.correct { border-color: #34c38f; background: #f1fff6; }
    .sentence-assembly.incorrect { border-color: #ff6c6c; background: #fff5f5; }
    .sentence-placeholder { color: #8a94a6; font-size: 14px; }
    .sentence-token {
      border: 1px solid #ccd4ff;
      border-radius: 12px;
      background: #eef2ff;
      padding: 10px 16px;
      font-size: 15px;
      color: #33426f;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      flex: none;
      box-shadow: 0 6px 12px rgba(92, 112, 187, 0.18);
    }
    .sentence-token:hover { background: #dbe4ff; }
    .sentence-token.disabled { opacity: 0.45; cursor: not-allowed; box-shadow: none; }
    .sentence-token.assembled { background: #ffffff; }
    .sentence-token.removeable:hover { background: #ffecec; border-color: #ffb3b3; }
    .sentence-hint { margin-top: 6px; font-size: 14px; color: #4b5675; background: #f7f9ff; border: 1px solid #dce3f5; border-radius: 10px; padding: 12px; }
    .quiz-summary {
      padding: 24px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(245, 248, 255, 0.95), #ffffff);
      border: 1px solid #d6deed;
      font-size: 15px;
      color: #4b5675;
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: flex-start;
    }
    .quiz-summary strong { color: #2c3e50; }
    .practice-chip {
      display: inline-flex;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #7a89ff, #9a5bff);
    }
    .practice-toolbar .toolbar-hint {
      font-size: 13px;
      color: #5d689c;
    }
    @media (max-width: 768px) {
      .practice-shell { padding: 0 16px 40px; }
      .practice-header { flex-direction: column; align-items: flex-start; gap: 18px; }
      .practice-header-actions { width: 100%; justify-content: space-between; }
      .practice-content { padding: 20px 18px; }
      .toolbar-section { flex-direction: column; align-items: stretch; }
      .toolbar-section input[type="search"],
      .toolbar-section select { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="practice-shell">
    <header class="practice-header">
      <div class="practice-logo"><span>ğŸ“š</span>è‹±è¯­æåˆ†ç³»ç»Ÿ Â· ç»ƒä¹ æ¨¡å¼</div>
      <div class="practice-header-actions">
        <div class="type-switch">
          <button class="type-btn" data-practice-type="word">è¯æ±‡ç»ƒä¹ </button>
          <button class="type-btn" data-practice-type="grammar">è¯­æ³•ç»ƒä¹ </button>
          <button class="type-btn" data-practice-type="sentence">å¥å­ç»ƒä¹ </button>
        </div>
        <button class="btn-ghost" id="btnBackHome">è¿”å›é¦–é¡µ</button>
      </div>
    </header>
    <div class="student-badge" id="studentBadge" style="display:none;"></div>
    <section id="practiceStats" class="practice-stats">æ­£åœ¨å‡†å¤‡ç»ƒä¹ ï¼Œè¯·ç¨å€™...</section>
    <section id="practiceToolbar" class="practice-toolbar" style="display:none;"></section>
    <section id="practiceContent" class="practice-content">
      <div class="loading-state"><span>æ­£åœ¨åŠ è½½é¢˜åº“èµ„æº...</span></div>
    </section>
  </div>

  <script src="data-loader.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const practiceStats = document.getElementById('practiceStats');
    const practiceToolbar = document.getElementById('practiceToolbar');
    const practiceContent = document.getElementById('practiceContent');
    const studentBadge = document.getElementById('studentBadge');

    const practiceState = {
      type: urlParams.get('type') || 'word',
      datasetId: urlParams.get('dataset') || null,
      queue: [],
      index: 0,
      answered: 0,
      correct: 0,
      reveal: false,
      queueSourceId: null,
      assetsReady: false
    };

    const studentName = urlParams.get('student');
    if (studentName) {
      studentBadge.style.display = 'inline-flex';
      studentBadge.innerHTML = `<span>å½“å‰å­¦ç”Ÿï¼š</span>${studentName}`;
    }

    document.querySelectorAll('[data-practice-type]').forEach(btn => {
      btn.addEventListener('click', () => setPracticeType(btn.dataset.practiceType));
    });

    document.getElementById('btnBackHome').addEventListener('click', () => {
      window.location.href = 'index.html';
    });

    function updateTypeButtons() {
      document.querySelectorAll('[data-practice-type]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.practiceType === practiceState.type);
      });
    }

    function setPracticeType(type) {
      if (!type) return;
      practiceState.type = type;
      practiceState.datasetId = null;
      resetProgress();
      updateURL();
      updateTypeButtons();
      renderCurrentPractice();
    }

    function updateURL() {
      const url = new URL(window.location.href);
      url.searchParams.set('type', practiceState.type);
      if (practiceState.datasetId) {
        url.searchParams.set('dataset', practiceState.datasetId);
      } else {
        url.searchParams.delete('dataset');
      }
      if (studentName) {
        url.searchParams.set('student', studentName);
      }
      history.replaceState({}, '', url);
    }

    function resetProgress() {
      practiceState.queue = [];
      practiceState.index = 0;
      practiceState.answered = 0;
      practiceState.correct = 0;
      practiceState.reveal = false;
      practiceState.queueSourceId = null;
    }

    function renderCurrentPractice() {
      if (!practiceState.assetsReady) {
        practiceStats.textContent = 'èµ„æºåŠ è½½ä¸­ï¼Œè¯·ç¨å€™...';
        practiceToolbar.style.display = 'none';
        practiceContent.innerHTML = '<div class="loading-state"><span>æ­£åœ¨åŠ è½½é¢˜åº“èµ„æº...</span></div>';
        return;
      }
      practiceToolbar.style.display = 'flex';
      switch (practiceState.type) {
        case 'grammar':
          renderGrammarPractice();
          break;
        case 'sentence':
          renderSentencePractice();
          break;
        case 'word':
        default:
          renderWordPractice();
          break;
      }
    }

    function updateQuizProgress(total, label) {
      const current = Math.min(practiceState.index + 1, total);
      const accuracy = practiceState.answered ? Math.round((practiceState.correct / practiceState.answered) * 100) : 0;
      const prefix = label ? `${label} Â· ` : '';
      practiceStats.textContent = `${prefix}è¿›åº¦ï¼šç¬¬ ${current}/${total} é¢˜ Â· å·²ç­” ${practiceState.answered} é¢˜ Â· æ­£ç¡®ç‡ ${accuracy}%`;
    }


function renderWordPractice() {
  const datasets = collectVocabularyDatasets();

  if (!datasets.length) {
    practiceToolbar.innerHTML = '';
    practiceContent.innerHTML = '<div class="practice-empty">æš‚æœªæ£€æµ‹åˆ°è¯æ±‡æ•°æ®ï¼Œè¯·ç¡®è®¤è¯æ±‡è„šæœ¬å·²æˆåŠŸåŠ è½½ã€‚</div>';
    practiceStats.textContent = 'è¯æ±‡æ•°æ®æœªåŠ è½½';
    return;
  }

  if (!practiceState.datasetId || !datasets.some(dataset => dataset.id === practiceState.datasetId)) {
    practiceState.datasetId = datasets[0].id;
    resetProgress();
    updateURL();
  }

  const dataset = datasets.find(item => item.id === practiceState.datasetId) || datasets[0];
  const optionsHtml = buildVocabularyOptions(datasets, dataset.id);
  const hintText = dataset.description || 'ç³»ç»Ÿä¼šéšæœºæŠ½å–è¯æ±‡è¿›è¡Œå››é€‰ä¸€é‡Šä¹‰æµ‹è¯•ï¼Œè¯·é€‰æ‹©æ­£ç¡®ä¸­æ–‡é‡Šä¹‰';

  practiceToolbar.innerHTML = `
    <div class="toolbar-section">
      <label for="wordDataset">é€‰æ‹©è¯åº“</label>
      <select id="wordDataset">${optionsHtml}</select>
      <span class="toolbar-hint">${hintText}</span>
    </div>
    <div class="toolbar-actions">
      <button class="btn-secondary" id="wordRestartBtn">é‡æ–°å¼€å§‹</button>
    </div>
  `;

  document.getElementById('wordDataset').addEventListener('change', event => {
    practiceState.datasetId = event.target.value;
    resetProgress();
    updateURL();
    renderWordPractice();
  });

  document.getElementById('wordRestartBtn').addEventListener('click', () => {
    resetProgress();
    renderWordPractice();
  });

  renderWordQuiz(dataset);
}

function renderWordQuiz(dataset) {
  if (!dataset || !Array.isArray(dataset.entries) || !dataset.entries.length) {
    practiceContent.innerHTML = '<div class="practice-empty">è¯¥è¯åº“æš‚æ— è¯æ¡ï¼Œè¯·é€‰æ‹©å…¶ä»–è¯åº“ã€‚</div>';
    practiceStats.textContent = `${dataset ? dataset.title : 'è¯æ±‡ç»ƒä¹ '} æš‚æ— è¯æ¡`;
    return;
  }

  if (practiceState.queueSourceId !== dataset.id) {
    practiceState.queue = [];
  }

  if (!practiceState.queue.length) {
    practiceState.queue = shuffle(dataset.entries.slice());
    practiceState.queueSourceId = dataset.id;
    practiceState.index = 0;
    practiceState.answered = 0;
    practiceState.correct = 0;
    practiceState.reveal = false;
  }

  const total = practiceState.queue.length;
  if (practiceState.index >= total) {
    showWordSummary(dataset);
    return;
  }

  const current = practiceState.queue[practiceState.index];
  const availableEntries = dataset.entries.filter(item => item !== current && item.cn);
  const distractorPool = shuffle(availableEntries);
  const distractors = [];
  const seenTranslations = new Set();
  const correctTranslation = (current.cn || '').trim();

  for (const candidate of distractorPool) {
    const translation = (candidate.cn || '').trim();
    if (!translation) continue;
    const normalized = translation.toLowerCase();
    if (normalized === correctTranslation.toLowerCase() || seenTranslations.has(normalized)) continue;
    distractors.push(candidate);
    seenTranslations.add(normalized);
    if (distractors.length === 3) break;
  }

  while (distractors.length < 3) {
    distractors.push({ word: '', cn: 'ï¼ˆå¾…è¡¥å……ï¼‰' });
  }

  const optionData = shuffle([
    { isCorrect: true, text: current.cn || 'æš‚æ— ä¸­æ–‡é‡Šä¹‰' },
    ...distractors.slice(0, 3).map(item => ({ isCorrect: false, text: item.cn || 'ï¼ˆå¾…è¡¥å……ï¼‰' }))
  ]).map((option, index) => ({ ...option, letter: String.fromCharCode(65 + index) }));

  const answerDetails = [
    `æ­£ç¡®é‡Šä¹‰ï¼š<strong>${current.cn || 'æš‚æ— ä¸­æ–‡é‡Šä¹‰'}</strong>`,
    current.pos ? `è¯æ€§ï¼š${current.pos}` : '',
    current.example ? `ä¾‹å¥ï¼š${current.example}` : '',
    current.note ? `è¯´æ˜ï¼š${current.note}` : ''
  ].filter(Boolean).join('<br>');

  practiceContent.innerHTML = `
    <div class="quiz-card">
      <div class="quiz-header">
        <span>${dataset.title}</span>
        <span>æ­£ç¡® ${practiceState.correct}/${practiceState.answered}</span>
      </div>
      <div class="quiz-prompt">${current.word || ''}</div>
      ${current.freq ? `<div class="practice-entry-meta">é¢‘ç‡æŒ‡æ•°ï¼š${current.freq}</div>` : ''}
      <div class="quiz-options">
        ${optionData.map(option => `<button class="quiz-option" data-correct="${option.isCorrect ? '1' : '0'}"><strong>${option.letter}.</strong> ${option.text}</button>`).join('')}
      </div>
      <div id="wordAnswer" class="quiz-answer hidden">${answerDetails || 'æš‚æ— è§£æï¼Œè¯·è”ç³»æ•™å¸ˆè¡¥å……è¯æ±‡ä¿¡æ¯ã€‚'}</div>
      <div class="quiz-actions">
        <span class="quiz-hint">é€‰æ‹©ä¸€ä¸ªé€‰é¡¹æŸ¥çœ‹ç­”æ¡ˆå¹¶è¿›å…¥ä¸‹ä¸€é¢˜ã€‚</span>
        <div style="display:flex;gap:10px;">
          <button class="btn-secondary" id="wordSkipBtn">è·³è¿‡æ­¤é¢˜</button>
          <button class="btn-accent" id="wordNextBtn" disabled>ä¸‹ä¸€é¢˜</button>
        </div>
      </div>
    </div>
  `;

  updateQuizProgress(total, dataset.title);

  const answerBox = document.getElementById('wordAnswer');
  const nextBtn = document.getElementById('wordNextBtn');
  const skipBtn = document.getElementById('wordSkipBtn');
  const optionButtons = Array.from(document.querySelectorAll('.quiz-option'));

  optionButtons.forEach(button => {
    button.addEventListener('click', () => {
      if (practiceState.reveal) return;
      const isCorrect = button.dataset.correct === '1';
      practiceState.reveal = true;
      practiceState.answered++;
      if (isCorrect) {
        practiceState.correct++;
        button.classList.add('correct');
      } else {
        button.classList.add('incorrect');
        const correctButton = optionButtons.find(btn => btn.dataset.correct === '1');
        if (correctButton) correctButton.classList.add('correct');
      }
      optionButtons.forEach(btn => btn.disabled = true);
      answerBox.classList.remove('hidden');
      nextBtn.disabled = false;
      updateQuizProgress(total, dataset.title);
    });
  });

  nextBtn.addEventListener('click', () => {
    practiceState.index++;
    practiceState.reveal = false;
    renderWordQuiz(dataset);
  });

  skipBtn.addEventListener('click', () => {
    practiceState.index++;
    practiceState.reveal = false;
    renderWordQuiz(dataset);
  });
}

function showWordSummary(dataset) {
  const answered = practiceState.answered;
  const accuracy = answered ? Math.round((practiceState.correct / answered) * 100) : 0;
  const poolSize = dataset.entries.length;

  practiceStats.textContent = `${dataset.title} ç»ƒä¹ å®Œæˆ Â· ä½œç­” ${answered} / ${poolSize} è¯æ¡ Â· æ­£ç¡® ${practiceState.correct} Â· æ­£ç¡®ç‡ ${accuracy}%`;

  practiceContent.innerHTML = `
    <div class="quiz-summary">
      <strong>ç»ƒä¹ å®Œæˆï¼</strong>
      <p>æœ¬è½®å…±ä½œç­” ${answered} ä¸ªè¯æ¡ï¼Œç­”å¯¹ ${practiceState.correct} ä¸ªï¼Œæ­£ç¡®ç‡ ${accuracy}%ã€‚</p>
      <div style="display:flex;gap:12px;flex-wrap:wrap;">
        <button class="btn-accent" id="wordRetryAll">é‡æ–°ç»ƒä¹ </button>
      </div>
    </div>
  `;

  document.getElementById('wordRetryAll').addEventListener('click', () => {
    resetProgress();
    renderWordPractice();
  });
}


function buildVocabularyOptions(datasets, selectedId) {
  const groupMap = new Map();
  datasets.forEach(dataset => {
    const groupName = dataset.group || 'è¯æ±‡åº“';
    if (!groupMap.has(groupName)) groupMap.set(groupName, []);
    groupMap.get(groupName).push(dataset);
  });
  return Array.from(groupMap.entries()).map(([groupName, items]) => {
    const options = items.map(item => `<option value="${item.id}" ${item.id === selectedId ? 'selected' : ''}>${item.title}ï¼ˆ${item.total}è¯ï¼‰</option>`).join('');
    return `<optgroup label="${groupName}">${options}</optgroup>`;
  }).join('');
}

function collectVocabularyDatasets() {
  const datasets = [];

  if (Array.isArray(window.vocabulary688) && window.vocabulary688.length) {
    const entries = window.vocabulary688
      .filter(item => item && item.word)
      .map(item => ({
        word: item.word,
        cn: item.cn || item.translation || '',
        pos: item.pos || item.type || '',
        example: item.example || '',
        freq: item.freq || ''
      }));
    if (entries.length) {
      datasets.push({
        id: 'core-688',
        title: 'æ ¸å¿ƒ688è¯æ±‡',
        entries,
        total: entries.length,
        group: 'æ ¸å¿ƒè¯æ±‡',
        description: 'é«˜è€ƒæ ¸å¿ƒ 688 è¯æ±‡ï¼Œè¦†ç›–å¸¸è§è€ƒè¯•é«˜é¢‘è¯ã€‚'
      });
    }
  }

  if (window.textbookVocab && typeof window.textbookVocab === 'object') {
    let unitIndex = 0;
    Object.entries(window.textbookVocab).forEach(([bookId, book]) => {
      const bookName = book && book.name ? book.name : bookId;
      const units = book && book.units ? book.units : {};
      Object.entries(units).forEach(([unitName, unitContent]) => {
        const entries = extractTextbookUnitEntries(unitContent, unitName);
        if (!entries.length) return;
        const slug = `${slugify(bookId)}-${slugify(unitName)}-${unitIndex}`;
        datasets.push({
          id: `textbook-${slug}`,
          title: `${bookName} Â· ${unitName}`,
          entries,
          total: entries.length,
          group: 'æ•™æè¯æ±‡',
          description: `${bookName} ${unitName}`
        });
        unitIndex += 1;
      });
    });
  }

  if (window.vocab3500 && typeof window.vocab3500 === 'object') {
    Object.keys(window.vocab3500).sort().forEach(letter => {
      const list = window.vocab3500[letter];
      if (!Array.isArray(list) || !list.length) return;
      const entries = list
        .filter(item => item && item.word)
        .map(item => normalize3500Entry(item))
        .filter(Boolean);
      if (!entries.length) return;
      datasets.push({
        id: `vocab3500-${letter}`,
        title: `é«˜è€ƒ3500è¯ Â· ${letter}`,
        entries,
        total: entries.length,
        group: 'é«˜è€ƒ3500è¯'
      });
    });
  }

  return datasets;
}

function normalize3500Entry(item) {
  if (!item || !item.word) return null;
  const meanings = [];
  const types = [];
  ['meaning', 'meaning2', 'meaning3', 'meaning4'].forEach(key => {
    if (item[key]) meanings.push(String(item[key]));
  });
  ['type', 'type2', 'type3', 'type4'].forEach(key => {
    if (item[key]) types.push(String(item[key]));
  });
  return {
    word: item.word,
    cn: meanings.join('ï¼›') || '',
    pos: types.join('ï¼›') || ''
  };
}

function extractTextbookUnitEntries(unitContent, sectionLabel) {
  const entries = [];
  if (!unitContent || typeof unitContent !== 'object') return entries;
  Object.entries(unitContent).forEach(([categoryName, items]) => {
    if (!Array.isArray(items)) return;
    items.forEach(item => {
      const word = item.word || item.phrase || item.expression || item.idiom;
      const translation = item.translation || item.cn || item.meaning || '';
      if (!word || !translation) return;
      entries.push({
        word,
        cn: translation,
        pos: categoryName,
        note: sectionLabel
      });
    });
  });
  return entries;
}

function slugify(value) {
  if (value === null || value === undefined) return Math.random().toString(36).slice(2, 8);
  const raw = String(value).trim();
  if (!raw) return Math.random().toString(36).slice(2, 8);
  const ascii = raw.toLowerCase().replace(/[^0-9a-z]+/g, '-').replace(/^-+|-+$/g, '');
  if (ascii) return ascii;
  const encoded = encodeURIComponent(raw).replace(/%/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
  return encoded || Math.random().toString(36).slice(2, 8);
}
    function renderGrammarPractice() {
      const datasets = collectGrammarDatasets();
      if (!datasets.length) {
        practiceToolbar.innerHTML = '';
        practiceContent.innerHTML = '<div class="practice-empty">å°šæœªåŠ è½½è¯­æ³•é¢˜åº“æ•°æ®ï¼Œè¯·ç¨åé‡è¯•ã€‚</div>';
        practiceStats.textContent = 'è¯­æ³•é¢˜åº“æœªåŠ è½½';
        return;
      }

      if (!practiceState.datasetId || !datasets.some(item => item.id === practiceState.datasetId)) {
        practiceState.datasetId = datasets[0].id;
        resetProgress();
        updateURL();
      }

      const optionsHtml = buildGrammarOptions(datasets, practiceState.datasetId);

      practiceToolbar.innerHTML = `
        <div class="toolbar-section">
          <label for="grammarDataset">é€‰æ‹©é¢˜åº“</label>
          <select id="grammarDataset">${optionsHtml}</select>
          <span class="toolbar-hint">éšæœºæŠ½å–é€‰æ‹©é¢˜ï¼Œé€‰æ‹©æ­£ç¡®ç­”æ¡ˆå¹¶æŸ¥çœ‹è§£æ</span>
        </div>
        <div class="toolbar-actions">
          <button class="btn-secondary" id="grammarRestartBtn">é‡æ–°ç»ƒä¹ </button>
        </div>
      `;

      document.getElementById('grammarDataset').addEventListener('change', event => {
        practiceState.datasetId = event.target.value;
        resetProgress();
        updateURL();
        renderGrammarPractice();
      });

      document.getElementById('grammarRestartBtn').addEventListener('click', () => {
        resetProgress();
        renderGrammarPractice();
      });

      const dataset = datasets.find(item => item.id === practiceState.datasetId) || datasets[0];
      renderGrammarQuiz(dataset);
    }

    function buildGrammarOptions(datasets, currentId) {
      const groups = datasets.reduce((acc, dataset) => {
        const group = dataset.group || 'è¯­æ³•é¢˜åº“';
        if (!acc[group]) acc[group] = [];
        acc[group].push(dataset);
        return acc;
      }, {});
      return Object.entries(groups).map(([groupName, items]) => {
        const options = items.map(item => `<option value="${item.id}" ${item.id === currentId ? 'selected' : ''}>${item.title}ï¼ˆ${item.total}é¢˜ï¼‰</option>`).join('');
        return `<optgroup label="${groupName}">${options}</optgroup>`;
      }).join('');
    }

    function renderGrammarQuiz(dataset) {
      if (!Array.isArray(dataset.questions) || !dataset.questions.length) {
        practiceContent.innerHTML = '<div class="practice-empty">è¯¥é¢˜åº“æš‚æ— é¢˜ç›®ï¼Œè¯·é€‰æ‹©å…¶å®ƒé¢˜åº“ã€‚</div>';
        practiceStats.textContent = `${dataset.title} æš‚æ— é¢˜ç›®`;
        return;
      }

      if (!practiceState.queue.length) {
        practiceState.queue = shuffle(dataset.questions.slice());
        practiceState.index = 0;
        practiceState.correct = 0;
        practiceState.answered = 0;
        practiceState.reveal = false;
      }

      const total = practiceState.queue.length;

      if (practiceState.index >= total) {
        showGrammarSummary(dataset);
        return;
      }

      const current = practiceState.queue[practiceState.index];
      const optionPairs = Array.isArray(current.options)
        ? current.options.map((value, index) => ({ key: String.fromCharCode(65 + index), value: stripOptionPrefix(value) }))
        : Object.entries(current.options || {}).map(([key, value]) => ({ key, value: stripOptionPrefix(value) }));

      const normalizedAnswer = (current.answer || current.correctAnswer || '').toString().trim().toUpperCase();

      practiceContent.innerHTML = `
        <div class="quiz-card">
          <div class="quiz-header">
            <span>${dataset.title}</span>
            <span>æ­£ç¡® ${practiceState.correct}/${practiceState.answered}</span>
          </div>
          <div class="quiz-prompt">${practiceState.index + 1}. ${current.question || 'é¢˜ç›®ç¼ºå¤±'}</div>
          ${current.section ? `<div class="practice-entry-meta">æ‰€å±æ¨¡å—ï¼š${current.section}</div>` : ''}
          ${current.knowledge ? `<div class="practice-entry-meta">çŸ¥è¯†ç‚¹ï¼š${current.knowledge}</div>` : ''}
          <div class="quiz-options">
            ${optionPairs.map(option => `<button class="quiz-option" data-option="${option.key}"><strong>${option.key}.</strong> ${option.value}</button>`).join('')}
          </div>
          <div id="grammarAnswer" class="quiz-answer hidden">${buildGrammarAnswerBlock(current, normalizedAnswer)}</div>
          <div class="quiz-actions">
            <span class="quiz-hint">é€‰æ‹©ä¸€ä¸ªé€‰é¡¹ï¼ŒæŸ¥çœ‹è§£æå¹¶è¿›å…¥ä¸‹ä¸€é¢˜ã€‚</span>
            <div style="display:flex;gap:10px;">
              <button class="btn-secondary" id="grammarSkipBtn">è·³è¿‡æ­¤é¢˜</button>
              <button class="btn-accent" id="grammarNextBtn" disabled>ä¸‹ä¸€é¢˜</button>
            </div>
          </div>
        </div>
      `;

      updateQuizProgress(total, dataset.title);

      const answerBox = document.getElementById('grammarAnswer');
      const nextBtn = document.getElementById('grammarNextBtn');
      const skipBtn = document.getElementById('grammarSkipBtn');
      const optionButtons = Array.from(document.querySelectorAll('.quiz-option'));

      optionButtons.forEach(button => {
        button.addEventListener('click', () => {
          if (practiceState.reveal) return;
          const choice = (button.dataset.option || '').toUpperCase();
          const isCorrect = normalizedAnswer ? choice === normalizedAnswer : false;

          practiceState.reveal = true;
          practiceState.answered++;
          if (isCorrect) {
            practiceState.correct++;
            button.classList.add('correct');
          } else {
            button.classList.add('incorrect');
            if (normalizedAnswer) {
              const correctButton = optionButtons.find(btn => (btn.dataset.option || '').toUpperCase() === normalizedAnswer);
              if (correctButton) correctButton.classList.add('correct');
            }
          }

          optionButtons.forEach(btn => btn.disabled = true);
          answerBox.classList.remove('hidden');
          nextBtn.disabled = false;
          updateQuizProgress(total, dataset.title);
        });
      });

      nextBtn.addEventListener('click', () => {
        practiceState.index++;
        practiceState.reveal = false;
        renderGrammarPractice();
      });

      skipBtn.addEventListener('click', () => {
        practiceState.index++;
        practiceState.reveal = false;
        renderGrammarPractice();
      });
    }

    function showGrammarSummary(dataset) {
      const total = practiceState.queue.length;
      const answered = practiceState.answered;
      const accuracy = answered ? Math.round((practiceState.correct / answered) * 100) : 0;

      practiceStats.textContent = `${dataset.title} ç»ƒä¹ å®Œæˆ Â· ä½œç­” ${answered} é¢˜ Â· æ­£ç¡®ç‡ ${accuracy}%`;

      practiceContent.innerHTML = `
        <div class="quiz-summary">
          <strong>ç»ƒä¹ å®Œæˆï¼</strong>
          <p>${dataset.title} å…± ${total} é¢˜ï¼Œæœ¬è½®ä½œç­” ${answered} é¢˜ï¼Œç­”å¯¹ ${practiceState.correct} é¢˜ï¼Œæ­£ç¡®ç‡ ${accuracy}%ã€‚</p>
          <div style="display:flex;gap:12px;flex-wrap:wrap;">
            <button class="btn-accent" id="grammarRetry">é‡æ–°ç»ƒä¹ </button>
          </div>
        </div>
      `;

      document.getElementById('grammarRetry').addEventListener('click', () => {
        resetProgress();
        renderGrammarPractice();
      });
    }

    function renderSentencePractice() {
      const datasets = collectSentenceDatasets();
      if (!datasets.length) {
        practiceToolbar.innerHTML = '';
        practiceContent.innerHTML = '<div class="practice-empty">å°šæœªåŠ è½½å¥å­æˆ–ä½œæ–‡æ¨¡æ¿æ•°æ®ï¼Œè¯·ç¨åé‡è¯•ã€‚</div>';
        practiceStats.textContent = 'å¥å­æ•°æ®æœªåŠ è½½';
        return;
      }

      if (!practiceState.datasetId || !datasets.some(item => item.id === practiceState.datasetId)) {
        practiceState.datasetId = datasets[0].id;
        resetProgress();
        updateURL();
      }

      const options = datasets.map(dataset => `<option value="${dataset.id}" ${dataset.id === practiceState.datasetId ? 'selected' : ''}>${dataset.title}ï¼ˆ${dataset.total}å¥ï¼‰</option>`).join('');

      practiceToolbar.innerHTML = `
        <div class="toolbar-section">
          <label for="sentenceDataset">é€‰æ‹©ç´ æ</label>
          <select id="sentenceDataset">${options}</select>
          <span class="toolbar-hint">ç‚¹å‡»ä¸‹æ–¹è¯å—ï¼ŒæŒ‰æ­£ç¡®é¡ºåºè¿˜åŸå¥å­</span>
        </div>
        <div class="toolbar-actions">
          <button class="btn-secondary" id="sentenceRestartBtn">é‡æ–°ç»ƒä¹ </button>
        </div>
      `;

      document.getElementById('sentenceDataset').addEventListener('change', event => {
        practiceState.datasetId = event.target.value;
        resetProgress();
        updateURL();
        renderSentencePractice();
      });

      document.getElementById('sentenceRestartBtn').addEventListener('click', () => {
        resetProgress();
        renderSentencePractice();
      });

      const dataset = datasets.find(entry => entry.id === practiceState.datasetId) || datasets[0];
      renderSentenceQuiz(dataset);
    }

    function collectSentenceDatasets() {
      const datasets = [];
      const baseSentences = Array.isArray(window.vocabularyData) ? window.vocabularyData : [];
      if (baseSentences.length) {
        datasets.push({
          id: 'sentences',
          title: 'ç²¾é€‰å¥å­200',
          total: baseSentences.length,
          items: baseSentences.map((item, index) => ({
            index: item.id || index + 1,
            english: item.english,
            chinese: item.chinese,
            keywords: Array.isArray(item.keywords) ? item.keywords : []
          }))
        });
      }

      const essayConfigs = [
        { key: 'activityIntroduction', label: 'ä½œæ–‡æ¨¡æ¿ Â· æ´»åŠ¨ä»‹ç»' },
        { key: 'activityReport', label: 'ä½œæ–‡æ¨¡æ¿ Â· æ´»åŠ¨æŠ¥å‘Š' },
        { key: 'apologyLetter', label: 'ä½œæ–‡æ¨¡æ¿ Â· é“æ­‰ä¿¡' },
        { key: 'applicationLetter', label: 'ä½œæ–‡æ¨¡æ¿ Â· ç”³è¯·ä¿¡' },
        { key: 'invitationContent', label: 'ä½œæ–‡æ¨¡æ¿ Â· é‚€è¯·ä¿¡' },
        { key: 'noticeLetter', label: 'ä½œæ–‡æ¨¡æ¿ Â· é€šçŸ¥ä¿¡' },
        { key: 'personDescription', label: 'ä½œæ–‡æ¨¡æ¿ Â· äººç‰©ä»‹ç»' },
        { key: 'suggestionLetter', label: 'ä½œæ–‡æ¨¡æ¿ Â· å»ºè®®ä¿¡' }
      ];

      essayConfigs.forEach(cfg => {
        const source = window[cfg.key];
        if (!source || !Array.isArray(source.sentences) || !source.sentences.length) return;
        const title = source.title?.chinese || source.title?.english || cfg.label;
        datasets.push({
          id: cfg.key,
          title,
          total: source.sentences.length,
          items: source.sentences.map((sentence, index) => ({
            index: index + 1,
            english: sentence.english,
            chinese: sentence.chinese,
            keywords: Array.isArray(sentence.keywords) ? sentence.keywords : []
          }))
        });
      });

      return datasets;
    }

    function renderSentenceQuiz(dataset) {
      if (!Array.isArray(dataset.items) || !dataset.items.length) {
        practiceContent.innerHTML = '<div class="practice-empty">è¯¥ç´ ææš‚æ— å¯ç”¨å¥å­ï¼Œè¯·é€‰æ‹©å…¶å®ƒç´ æã€‚</div>';
        practiceStats.textContent = `${dataset.title} æš‚æ— å¥å­`;
        return;
      }

      if (!practiceState.queue.length) {
        practiceState.queue = shuffle(dataset.items.slice());
        practiceState.index = 0;
        practiceState.correct = 0;
        practiceState.answered = 0;
        practiceState.reveal = false;
      }

      const total = practiceState.queue.length;

      if (practiceState.index >= total) {
        showSentenceSummary(dataset);
        return;
      }

      const current = practiceState.queue[practiceState.index];
      const translation = current.chinese || '';
      const keywords = Array.isArray(current.keywords) ? current.keywords : [];
      const keywordText = keywords.length ? keywords.join('ã€') : '';
      const originalTokens = splitSentenceIntoChunks(current.english);

      const wordPositions = [];
      originalTokens.forEach((token, index) => {
        if (isWordToken(token)) wordPositions.push(index);
      });

      if (!wordPositions.length) {
        practiceState.index++;
        renderSentencePractice();
        return;
      }

      const wordTokens = wordPositions.map((tokenIndex, wordIndex) => ({
        value: originalTokens[tokenIndex],
        key: `word-${wordIndex}`
      }));
      const originalWords = wordTokens.map(token => token.value);
      const shuffledTokens = shuffle(wordTokens.map(token => ({ ...token })));
      const referenceSentence = joinSentenceTokens(originalTokens);

      practiceContent.innerHTML = `
        <div class="quiz-card">
          <div class="quiz-header">
            <span>${dataset.title}</span>
            <span>æŒæ¡ ${practiceState.correct}/${practiceState.answered}</span>
          </div>
          <div class="quiz-prompt">è¯·ç‚¹å‡»ä¸‹æ–¹è¯å—ï¼ŒæŒ‰æ­£ç¡®é¡ºåºè¿˜åŸè‹±æ–‡å¥å­</div>
          ${keywordText ? `<div class="practice-entry-meta">å…³é”®è¯ï¼š${keywordText}</div>` : ''}
          <div id="sentenceHint" class="sentence-hint">ä¸­æ–‡æç¤ºï¼š${translation || 'æš‚æ— ä¸­æ–‡æç¤º'}</div>
          <div class="sentence-assembly is-empty" id="sentenceAssembly"></div>
          <div class="sentence-pool" id="sentencePool"></div>
          <div id="sentenceAnswer" class="quiz-answer hidden"></div>
          <div class="quiz-actions">
            <span class="quiz-hint">å°†è¯å—æŒ‰é¡ºåºæ’åˆ—åï¼Œç‚¹å‡»â€œæ£€æŸ¥ç­”æ¡ˆâ€æŸ¥çœ‹ç»“æœã€‚</span>
            <div style="display:flex;gap:10px;flex-wrap:wrap;">
              <button class="btn-secondary" id="sentenceResetBtn">é‡ç½®</button>
              <button class="btn-secondary" id="sentenceHintBtn">éšè—ä¸­æ–‡æç¤º</button>
              <button class="btn-accent" id="sentenceCheckBtn" disabled>æ£€æŸ¥ç­”æ¡ˆ</button>
              <button class="btn-accent" id="sentenceNextBtn" disabled>ä¸‹ä¸€å¥</button>
            </div>
          </div>
        </div>
      `;

      updateQuizProgress(total, dataset.title);

      const assemblyContainer = document.getElementById('sentenceAssembly');
      const poolContainer = document.getElementById('sentencePool');
      const answerBox = document.getElementById('sentenceAnswer');
      const resetBtn = document.getElementById('sentenceResetBtn');
      const hintBtn = document.getElementById('sentenceHintBtn');
      const hintBox = document.getElementById('sentenceHint');
      const checkBtn = document.getElementById('sentenceCheckBtn');
      const nextBtn = document.getElementById('sentenceNextBtn');

      const assembled = [];
      const tokenButtonMap = new Map();
      let hintVisible = true;

      shuffledTokens.forEach(token => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'sentence-token';
        button.dataset.key = token.key;
        button.textContent = token.value;
        button.addEventListener('click', () => {
          if (practiceState.reveal || button.disabled) return;
          button.disabled = true;
          button.classList.add('disabled');
          assembled.push(token);
          renderAssembly();
          updateCheckButtonState();
        });
        tokenButtonMap.set(token.key, button);
        poolContainer.appendChild(button);
      });

      function renderAssembly() {
        assemblyContainer.classList.remove('correct', 'incorrect');
        assemblyContainer.innerHTML = '';
        if (!assembled.length) {
          assemblyContainer.classList.add('is-empty');
          assemblyContainer.innerHTML = '<span class="sentence-placeholder">ç‚¹å‡»ä¸‹æ–¹è¯å—è¿˜åŸå¥å­</span>';
          return;
        }
        assemblyContainer.classList.remove('is-empty');
        assembled.forEach(token => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'sentence-token assembled';
          button.dataset.key = token.key;
          button.textContent = token.value;
          if (!practiceState.reveal) {
            button.classList.add('removeable');
            button.addEventListener('click', () => {
              const index = assembled.findIndex(item => item.key === token.key);
              if (index !== -1) assembled.splice(index, 1);
              const poolButton = tokenButtonMap.get(token.key);
              if (poolButton) {
                poolButton.disabled = false;
                poolButton.classList.remove('disabled');
              }
              renderAssembly();
              updateCheckButtonState();
            });
          } else {
            button.disabled = true;
          }
          assemblyContainer.appendChild(button);
        });
      }

      function updateCheckButtonState() {
        checkBtn.disabled = practiceState.reveal || assembled.length !== originalWords.length;
      }

      resetBtn.addEventListener('click', () => {
        if (practiceState.reveal) return;
        assembled.length = 0;
        tokenButtonMap.forEach(button => {
          button.disabled = false;
          button.classList.remove('disabled');
        });
        renderAssembly();
        updateCheckButtonState();
      });

      hintBtn.addEventListener('click', () => {
        hintVisible = !hintVisible;
        hintBox.style.display = hintVisible ? 'block' : 'none';
        hintBtn.textContent = hintVisible ? 'éšè—ä¸­æ–‡æç¤º' : 'æ˜¾ç¤ºä¸­æ–‡æç¤º';
      });

      checkBtn.addEventListener('click', () => {
        if (practiceState.reveal) return;
        if (assembled.length !== originalWords.length) {
          alert('è¯·å…ˆé€‰å®Œæ‰€æœ‰è¯å—ã€‚');
          return;
        }
        const assembledWords = assembled.map(item => item.value);
        const isCorrect = compareWordOrder(originalWords, assembledWords);
        const assembledSentence = rebuildSentenceFromWords(originalTokens, assembledWords);

        practiceState.answered++;
        if (isCorrect) practiceState.correct++;
        practiceState.reveal = true;

        tokenButtonMap.forEach(button => {
          button.disabled = true;
          button.classList.add('disabled');
        });

        renderAssembly();
        assemblyContainer.classList.add(isCorrect ? 'correct' : 'incorrect');

        const resultLines = [
          `<strong>æ­£ç¡®å¥å­ï¼š</strong>${referenceSentence}`,
          translation ? `ä¸­æ–‡ï¼š${translation}` : '',
          keywordText ? `å…³é”®è¯ï¼š${keywordText}` : '',
          !isCorrect ? `<span style="color:#c0392b;">ä½ çš„ç­”æ¡ˆï¼š${assembledSentence}</span>` : ''
        ].filter(Boolean);

        answerBox.innerHTML = resultLines.join('<br>');
        answerBox.classList.remove('hidden');

        checkBtn.disabled = true;
        resetBtn.disabled = true;
        nextBtn.disabled = false;

        updateQuizProgress(total, dataset.title);
      });

      nextBtn.addEventListener('click', () => {
        practiceState.index++;
        practiceState.reveal = false;
        renderSentencePractice();
      });

      renderAssembly();
      updateCheckButtonState();
    }

    function showSentenceSummary(dataset) {
      const total = practiceState.queue.length;
      const answered = practiceState.answered;
      const accuracy = answered ? Math.round((practiceState.correct / answered) * 100) : 0;

      practiceStats.textContent = `${dataset.title} ç»ƒä¹ å®Œæˆ Â· ä½œç­” ${answered} å¥ Â· æ­£ç¡®ç‡ ${accuracy}%`;

      practiceContent.innerHTML = `
        <div class="quiz-summary">
          <strong>ç»ƒä¹ å®Œæˆï¼</strong>
          <p>${dataset.title} å…± ${total} å¥ï¼Œæœ¬è½®ä½œç­” ${answered} å¥ï¼Œæ ‡è®°æŒæ¡ ${practiceState.correct} å¥ï¼Œæ­£ç¡®ç‡ ${accuracy}%ã€‚</p>
          <div style="display:flex;gap:12px;flex-wrap:wrap;">
            <button class="btn-accent" id="sentenceRetry">é‡æ–°ç»ƒä¹ </button>
          </div>
        </div>
      `;

      document.getElementById('sentenceRetry').addEventListener('click', () => {
        resetProgress();
        renderSentencePractice();
      });
    }

    function collectGrammarDatasets() {
      const seen = new Set();
      const conceptDatasets = [];
      const choiceDatasets = [];
      const gapFillSource = collectGrammarGapFillDatasets();
      const gapFillDatasets = [];

      const addDataset = dataset => {
        if (!dataset || !Array.isArray(dataset.questions) || !dataset.questions.length) return;
        if (!dataset.id) dataset.id = `grammar-${seen.size + 1}`;
        if (seen.has(dataset.id)) return;
        dataset.total = dataset.questions.length;
        seen.add(dataset.id);
        if (dataset.group === 'è¯­æ³•é€‰æ‹©é¢˜åº“') {
          choiceDatasets.push(dataset);
        } else if (dataset.group === 'è¯­æ³•å¡«ç©ºé¢˜åº“') {
          gapFillDatasets.push(dataset);
        } else {
          conceptDatasets.push(dataset);
        }
      };

      if (window.englishGrammarConcepts && Array.isArray(window.englishGrammarConcepts.sections)) {
        const concept = window.englishGrammarConcepts;
        const allQuestions = flattenEnglishConcepts();
        if (allQuestions.length) {
          addDataset({
            id: 'concepts-all',
            title: concept.title || 'è¯­æ³•çŸ¥è¯†ç‚¹200é¢˜',
            questions: allQuestions,
            group: 'è¯­æ³•æ¦‚å¿µç²¾è¯»'
          });
        }
        concept.sections.forEach((section, index) => {
          const sectionQuestions = flattenEnglishConcepts(index);
          if (!sectionQuestions.length) return;
          const prefix = (index + 1).toString().padStart(2, '0');
          addDataset({
            id: `concepts-section-${index + 1}`,
            title: `${prefix} ${section.name || 'è¯­æ³•ç« èŠ‚'}`,
            questions: sectionQuestions,
            group: 'è¯­æ³•æ¦‚å¿µç²¾è¯»'
          });
        });
      }

      const banks = window.grammarQuestionBanks || {};
      const bankOrder = Array.isArray(window.grammarQuestionOrder) && window.grammarQuestionOrder.length
        ? window.grammarQuestionOrder
        : Object.keys(banks);
      bankOrder.forEach(id => {
        const bank = banks[id];
        if (!bank || !Array.isArray(bank.questions) || !bank.questions.length) return;
        addDataset({
          id,
          title: bank.title || id,
          questions: bank.questions.map(question => ({ ...question })),
          group: 'è¯­æ³•é€‰æ‹©é¢˜åº“'
        });
      });

      gapFillSource.forEach(dataset => addDataset(dataset));

      return [...conceptDatasets, ...choiceDatasets, ...gapFillDatasets];
    }
    function collectGrammarGapFillDatasets() {
      const configs = [
        { id: 'gap-articles', getter: () => (typeof articleExercises !== 'undefined' ? articleExercises : null), answerKey: 'answer', fallbackTitle: 'å† è¯ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-conjunctions', getter: () => (typeof conjunctions !== 'undefined' ? conjunctions : null), answerKey: 'answer', fallbackTitle: 'è¿è¯ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-prepositions', getter: () => (typeof prepositions !== 'undefined' ? prepositions : null), answerKey: 'answer', fallbackTitle: 'ä»‹è¯ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-pronouns', getter: () => (typeof pronouns !== 'undefined' ? pronouns : null), answerKey: 'answer', fallbackTitle: 'ä»£è¯ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-adverbial-clauses', getter: () => (typeof adverbialClauseTest !== 'undefined' ? adverbialClauseTest : null), answerKey: 'correctAnswer', fallbackTitle: 'çŠ¶è¯­ä»å¥ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-nonfinite-verbs', getter: () => (typeof nonFiniteVerbTest !== 'undefined' ? nonFiniteVerbTest : null), answerKey: 'correctAnswer', fallbackTitle: 'éè°“è¯­åŠ¨è¯ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-noun-clauses', getter: () => (typeof nounClauseTest !== 'undefined' ? nounClauseTest : null), answerKey: 'correctAnswer', fallbackTitle: 'åè¯æ€§ä»å¥ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-nouns', getter: () => (typeof nounTest !== 'undefined' ? nounTest : null), answerKey: 'correctAnswer', fallbackTitle: 'åè¯æ•°ä¸å¯æ•°æ€§ç»ƒä¹ ' },
        { id: 'gap-relative-clauses', getter: () => (typeof attributiveClauseTest !== 'undefined' ? attributiveClauseTest : null), answerKey: 'correctAnswer', fallbackTitle: 'å®šè¯­ä»å¥ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-verb-tense', getter: () => (typeof verbTenseTest !== 'undefined' ? verbTenseTest : null), answerKey: 'correctAnswer', fallbackTitle: 'åŠ¨è¯æ—¶æ€ä¸“é¢˜ç»ƒä¹ ' },
        { id: 'gap-verb-voice', getter: () => (typeof verbVoiceTest !== 'undefined' ? verbVoiceTest : null), answerKey: 'correctAnswer', fallbackTitle: 'åŠ¨è¯è¯­æ€ä¸“é¢˜ç»ƒä¹ ' }
      ];

      const datasets = [];
      configs.forEach(config => {
        const data = config.getter();
        if (!data) return;
        let questions = [];
        let title = '';
        if (Array.isArray(data)) {
          questions = normalizeGapFillQuestions(data, config.answerKey);
          title = config.fallbackTitle;
        } else if (typeof data === 'object') {
          const questionList = Array.isArray(data.questions) ? data.questions : Array.isArray(data.items) ? data.items : [];
          questions = normalizeGapFillQuestions(questionList, config.answerKey);
          title = data.title || config.fallbackTitle;
        }
        if (!questions.length) return;
        datasets.push({
          id: config.id,
          title: title || config.id,
          total: questions.length,
          questions,
          group: 'è¯­æ³•å¡«ç©ºé¢˜åº“'
        });
      });
      return datasets;
    }

    function normalizeGapFillQuestions(questions, answerKey) {
      if (!Array.isArray(questions)) return [];
      return questions.map(question => {
        const cloned = { ...question };
        if (Array.isArray(cloned.options)) {
          cloned.options = cloned.options.map(option => stripOptionPrefix(option));
        } else if (cloned.options && typeof cloned.options === 'object') {
          const normalized = {};
          Object.entries(cloned.options).forEach(([key, value]) => {
            normalized[key] = stripOptionPrefix(value);
          });
          cloned.options = normalized;
        }
        if (answerKey && typeof cloned[answerKey] !== 'undefined' && typeof cloned.answer === 'undefined') {
          cloned.answer = cloned[answerKey];
        }
        if (typeof cloned.answer === 'string') cloned.answer = cloned.answer.trim().toUpperCase();
        if (typeof cloned.correctAnswer === 'string') cloned.correctAnswer = cloned.correctAnswer.trim().toUpperCase();
        return cloned;
      });
    }

    function stripOptionPrefix(value) {
      if (typeof value !== 'string') return value;
      return value.replace(/^[A-Z][\.)]\s*/i, '').trim();
    }

    function buildGrammarAnswerBlock(question, answer) {
      const segments = [];
      const normalizedAnswer = answer ? answer.toString().trim().toUpperCase() : '';
      if (normalizedAnswer) segments.push(`æ­£ç¡®ç­”æ¡ˆï¼š<strong>${normalizedAnswer}</strong>`);
      if (question.translation) segments.push(`ç¿»è¯‘ï¼š${question.translation}`);
      if (question.explanation) segments.push(`è§£æï¼š${question.explanation}`);
      if (question.analysis && question.analysis !== question.explanation) segments.push(`è¡¥å……ï¼š${question.analysis}`);
      if (!segments.length) segments.push('æš‚æ— è§£æï¼Œè¯·ç»“åˆè¯¾å ‚ç¬”è®°å¤ä¹ ã€‚');
      return segments.join('<br>');
    }

    function flattenEnglishConcepts(sectionIndex) {
      if (!window.englishGrammarConcepts || !Array.isArray(window.englishGrammarConcepts.sections)) return [];
      const result = [];
      window.englishGrammarConcepts.sections.forEach((section, index) => {
        if (typeof sectionIndex === 'number' && index !== sectionIndex) return;
        const sectionName = section.name || '';
        (section.questions || []).forEach(question => {
          result.push({
            question: question.question,
            options: question.options,
            answer: question.answer,
            knowledge: question.knowledge,
            section: sectionName,
            explanation: question.explanation,
            analysis: question.analysis,
            translation: question.translation
          });
        });
      });
      return result;
    }

    function splitSentenceIntoChunks(sentence) {
      if (!sentence || typeof sentence !== 'string') return [];
      return (sentence.match(/[\w'-]+|[^\s\w]/g) || []).filter(Boolean);
    }

    function joinSentenceTokens(tokens) {
      return tokens.reduce((result, token) => {
        if (!token) return result;
        if (!result) return token;
        if (/^[,.;!?"â€')\]]/.test(token)) return result + token;
        if (token === "'s" || token === "'re" || token === "'ll" || token === "'ve" || token === "'d") return result + token;
        const trailing = result.slice(-1);
        if (['â€œ', '"', '(', '['].includes(trailing)) return result + token;
        return `${result} ${token}`;
      }, '');
    }

    function rebuildSentenceFromWords(templateTokens, words) {
      const tokens = [];
      let wordIndex = 0;
      templateTokens.forEach(token => {
        if (isWordToken(token)) {
          const replacement = typeof words[wordIndex] !== 'undefined' ? words[wordIndex] : token;
          tokens.push(replacement);
          wordIndex++;
        } else {
          tokens.push(token);
        }
      });
      return joinSentenceTokens(tokens);
    }

    function compareWordOrder(expected, actual) {
      if (!Array.isArray(actual) || actual.length !== expected.length) return false;
      return expected.every((value, index) => value.toLowerCase() === (actual[index] || '').toLowerCase());
    }

    function isWordToken(token) {
      return typeof token === 'string' && /^[A-Za-z0-9][A-Za-z0-9'\-]*$/.test(token);
    }

    function shuffle(array) {
      const result = array.slice();
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }

    function initPractice() {
      updateTypeButtons();
      practiceToolbar.style.display = 'none';
      practiceContent.innerHTML = '<div class="loading-state"><span>æ­£åœ¨åŠ è½½é¢˜åº“èµ„æº...</span></div>';

      if (typeof window.preloadLearningAssets === 'function') {
        window.preloadLearningAssets().then(() => {
          practiceState.assetsReady = true;
          renderCurrentPractice();
        }).catch(error => {
          console.error('åŠ è½½èµ„æºå¤±è´¥', error);
          practiceStats.textContent = 'èµ„æºåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚';
          practiceContent.innerHTML = '<div class="practice-empty">èµ„æºåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œååˆ·æ–°é¡µé¢ã€‚</div>';
        });
      } else {
        practiceState.assetsReady = true;
        renderCurrentPractice();
      }
    }

    initPractice();
  </script>
</body>
</html>
